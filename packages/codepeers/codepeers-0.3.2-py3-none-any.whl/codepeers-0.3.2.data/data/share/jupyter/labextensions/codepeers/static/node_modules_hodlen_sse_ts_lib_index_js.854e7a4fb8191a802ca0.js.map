{"version":3,"file":"node_modules_hodlen_sse_ts_lib_index_js.854e7a4fb8191a802ca0.js","mappings":";;;;;;;;;AAAa;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,uDAAO;;;;;;;;;;;AChBf;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,WAAW,GAAG,wBAAwB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACA;AACA,CAAC,kDAAkD,wBAAwB,KAAK;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,EAAE;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW","sources":["webpack://codepeers/./node_modules/@hodlen/sse.ts/lib/index.js","webpack://codepeers/./node_modules/@hodlen/sse.ts/lib/sse.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./sse\"), exports);\n","\"use strict\";\n/**\n * Copyright (C) 2021 Mukesh Agarwal <smartmuki@gmail.com>\n * All rights reserved.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SSE = exports.SSEOptionsMethod = void 0;\n/**\n * Copyright (C) 2016 Maxime Petazzoni <maxime.petazzoni@bulix.org>.\n * All rights reserved.\n */\nconst FIELD_SEPARATOR = \":\";\nvar XHRStates;\n(function (XHRStates) {\n    XHRStates[XHRStates[\"INITIALIZING\"] = -1] = \"INITIALIZING\";\n    XHRStates[XHRStates[\"CONNECTING\"] = 0] = \"CONNECTING\";\n    XHRStates[XHRStates[\"OPEN\"] = 1] = \"OPEN\";\n    XHRStates[XHRStates[\"CLOSED\"] = 2] = \"CLOSED\";\n})(XHRStates || (XHRStates = {}));\nvar SSEOptionsMethod;\n(function (SSEOptionsMethod) {\n    SSEOptionsMethod[\"GET\"] = \"GET\";\n    SSEOptionsMethod[\"POST\"] = \"POST\";\n})(SSEOptionsMethod = exports.SSEOptionsMethod || (exports.SSEOptionsMethod = {}));\nclass SSE {\n    constructor(url, options) {\n        this.url = url;\n        this.options = options;\n        this.listeners = {};\n        this.readyState = XHRStates.INITIALIZING;\n        this.chunk = \"\";\n        this.progress = 0;\n        if (!url) {\n            throw new Error(\"url cannot be null\");\n        }\n        if (!options || !options.method) {\n            throw new Error(\"Method is mandatory in `options`\");\n        }\n    }\n    addEventListener(type, listener) {\n        this.listeners[type] = this.listeners[type] || [];\n        if (this.listeners[type].indexOf(listener) === -1) {\n            this.listeners[type].push(listener);\n        }\n    }\n    removeEventListener(type, listener) {\n        if (!this.listeners[type]) {\n            return;\n        }\n        const filteredListeners = this.listeners[type].filter((lis) => lis !== listener);\n        if (!filteredListeners.length) {\n            delete this.listeners[type];\n        }\n        else {\n            this.listeners[type] = filteredListeners;\n        }\n    }\n    stream() {\n        this._setReadyState(XHRStates.CONNECTING);\n        const xhr = new XMLHttpRequest();\n        xhr.onreadystatechange = (evt) => this._checkStreamClosed(evt);\n        xhr.onprogress = (evt) => this._onStreamProgress(evt);\n        xhr.onload = (evt) => this._onStreamLoaded(evt);\n        xhr.onerror = (evt) => this._onStreamFailure(evt);\n        xhr.onabort = (evt) => this._onStreamFailure(evt);\n        xhr.open(this.options.method, this.url);\n        for (const header in this.options.headers) {\n            xhr.setRequestHeader(header, this.options.headers[header]);\n        }\n        xhr.withCredentials = !!this.options.withCredentials;\n        xhr.send(this.options.payload);\n        this.xhr = xhr;\n    }\n    close() {\n        var _a;\n        if (this.readyState === XHRStates.CLOSED) {\n            return;\n        }\n        (_a = this.xhr) === null || _a === void 0 ? void 0 : _a.abort();\n        this.xhr = undefined;\n        this._setReadyState(XHRStates.CLOSED);\n    }\n    dispatchEvent(e) {\n        if (!e) {\n            return true;\n        }\n        // e.source = this; Dont expose the SSE object\n        const onHandler = \"on\" + e.type;\n        if (this.hasOwnProperty(onHandler)) {\n            this[onHandler].call(this, e);\n            if (e.defaultPrevented) {\n                return false;\n            }\n        }\n        if (this.listeners[e.type]) {\n            return this.listeners[e.type].every((callback) => {\n                callback(e);\n                return !e.defaultPrevented;\n            });\n        }\n        return true;\n    }\n    _setReadyState(state) {\n        const event = new CustomEvent(\"readystatechange\");\n        event.readyState = state;\n        this.readyState = state;\n        this.dispatchEvent(event);\n    }\n    _onStreamFailure(e) {\n        const failureEvent = new CustomEvent(\"error\");\n        failureEvent.reason = e;\n        this.dispatchEvent(failureEvent);\n        this.close();\n    }\n    _onStreamProgress(e) {\n        if (!this.xhr) {\n            return;\n        }\n        if (this.xhr.status !== 200) {\n            this._onStreamFailure(e);\n            return;\n        }\n        if (this.readyState === XHRStates.CONNECTING) {\n            const openEvent = new CustomEvent(\"open\");\n            this.dispatchEvent(openEvent);\n            this._setReadyState(XHRStates.OPEN);\n        }\n        const data = this.xhr.responseText.substring(this.progress);\n        this.progress += data.length;\n        data.split(/(\\r\\n|\\r|\\n){2}/g).forEach((part) => {\n            if (part.trim().length === 0) {\n                const chunkEvent = this._parseEventChunk(this.chunk.trim());\n                if (chunkEvent !== null) {\n                    this.dispatchEvent(chunkEvent);\n                    this.chunk = \"\";\n                }\n            }\n            else {\n                this.chunk += part;\n            }\n        });\n    }\n    _onStreamLoaded(e) {\n        this._onStreamProgress(e);\n        const streamData = this._parseEventChunk(this.chunk);\n        if (streamData !== null) {\n            // Parse the last chunk.\n            this.dispatchEvent(streamData);\n            this.chunk = \"\";\n        }\n    }\n    /**\n     * Parse a received SSE event chunk into a constructed event object.\n     */\n    _parseEventChunk(chunk) {\n        if (!chunk || !chunk.length) {\n            return null;\n        }\n        const e = { id: null, retry: null, data: \"\", event: \"message\" };\n        chunk.split(/\\n|\\r\\n|\\r/).forEach((line) => {\n            line = line.trimEnd();\n            const index = line.indexOf(FIELD_SEPARATOR);\n            if (index <= 0) {\n                // Line was either empty, or started with a separator and is a comment.\n                // Either way, ignore.\n                return;\n            }\n            const field = line.substring(0, index);\n            if (!(field in e)) {\n                return;\n            }\n            const value = line.substring(index + 1).trimLeft();\n            if (field === \"data\") {\n                e[field] += value;\n            }\n            else {\n                e[field] = value;\n            }\n        });\n        const event = new CustomEvent(e.event);\n        event.data = e.data;\n        event.id = e.id;\n        return event;\n    }\n    _checkStreamClosed(e) {\n        if (!this.xhr) {\n            return;\n        }\n        if (this.xhr.readyState === XMLHttpRequest.DONE) {\n            this._setReadyState(XHRStates.CLOSED);\n        }\n    }\n}\nexports.SSE = SSE;\n"],"names":[],"sourceRoot":""}