"use strict";
(self["webpackChunkcodepeers"] = self["webpackChunkcodepeers"] || []).push([["node_modules_hodlen_sse_ts_lib_index_js"],{

/***/ "./node_modules/@hodlen/sse.ts/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@hodlen/sse.ts/lib/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./sse */ "./node_modules/@hodlen/sse.ts/lib/sse.js"), exports);


/***/ }),

/***/ "./node_modules/@hodlen/sse.ts/lib/sse.js":
/*!************************************************!*\
  !*** ./node_modules/@hodlen/sse.ts/lib/sse.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {


/**
 * Copyright (C) 2021 Mukesh Agarwal <smartmuki@gmail.com>
 * All rights reserved.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SSE = exports.SSEOptionsMethod = void 0;
/**
 * Copyright (C) 2016 Maxime Petazzoni <maxime.petazzoni@bulix.org>.
 * All rights reserved.
 */
const FIELD_SEPARATOR = ":";
var XHRStates;
(function (XHRStates) {
    XHRStates[XHRStates["INITIALIZING"] = -1] = "INITIALIZING";
    XHRStates[XHRStates["CONNECTING"] = 0] = "CONNECTING";
    XHRStates[XHRStates["OPEN"] = 1] = "OPEN";
    XHRStates[XHRStates["CLOSED"] = 2] = "CLOSED";
})(XHRStates || (XHRStates = {}));
var SSEOptionsMethod;
(function (SSEOptionsMethod) {
    SSEOptionsMethod["GET"] = "GET";
    SSEOptionsMethod["POST"] = "POST";
})(SSEOptionsMethod = exports.SSEOptionsMethod || (exports.SSEOptionsMethod = {}));
class SSE {
    constructor(url, options) {
        this.url = url;
        this.options = options;
        this.listeners = {};
        this.readyState = XHRStates.INITIALIZING;
        this.chunk = "";
        this.progress = 0;
        if (!url) {
            throw new Error("url cannot be null");
        }
        if (!options || !options.method) {
            throw new Error("Method is mandatory in `options`");
        }
    }
    addEventListener(type, listener) {
        this.listeners[type] = this.listeners[type] || [];
        if (this.listeners[type].indexOf(listener) === -1) {
            this.listeners[type].push(listener);
        }
    }
    removeEventListener(type, listener) {
        if (!this.listeners[type]) {
            return;
        }
        const filteredListeners = this.listeners[type].filter((lis) => lis !== listener);
        if (!filteredListeners.length) {
            delete this.listeners[type];
        }
        else {
            this.listeners[type] = filteredListeners;
        }
    }
    stream() {
        this._setReadyState(XHRStates.CONNECTING);
        const xhr = new XMLHttpRequest();
        xhr.onreadystatechange = (evt) => this._checkStreamClosed(evt);
        xhr.onprogress = (evt) => this._onStreamProgress(evt);
        xhr.onload = (evt) => this._onStreamLoaded(evt);
        xhr.onerror = (evt) => this._onStreamFailure(evt);
        xhr.onabort = (evt) => this._onStreamFailure(evt);
        xhr.open(this.options.method, this.url);
        for (const header in this.options.headers) {
            xhr.setRequestHeader(header, this.options.headers[header]);
        }
        xhr.withCredentials = !!this.options.withCredentials;
        xhr.send(this.options.payload);
        this.xhr = xhr;
    }
    close() {
        var _a;
        if (this.readyState === XHRStates.CLOSED) {
            return;
        }
        (_a = this.xhr) === null || _a === void 0 ? void 0 : _a.abort();
        this.xhr = undefined;
        this._setReadyState(XHRStates.CLOSED);
    }
    dispatchEvent(e) {
        if (!e) {
            return true;
        }
        // e.source = this; Dont expose the SSE object
        const onHandler = "on" + e.type;
        if (this.hasOwnProperty(onHandler)) {
            this[onHandler].call(this, e);
            if (e.defaultPrevented) {
                return false;
            }
        }
        if (this.listeners[e.type]) {
            return this.listeners[e.type].every((callback) => {
                callback(e);
                return !e.defaultPrevented;
            });
        }
        return true;
    }
    _setReadyState(state) {
        const event = new CustomEvent("readystatechange");
        event.readyState = state;
        this.readyState = state;
        this.dispatchEvent(event);
    }
    _onStreamFailure(e) {
        const failureEvent = new CustomEvent("error");
        failureEvent.reason = e;
        this.dispatchEvent(failureEvent);
        this.close();
    }
    _onStreamProgress(e) {
        if (!this.xhr) {
            return;
        }
        if (this.xhr.status !== 200) {
            this._onStreamFailure(e);
            return;
        }
        if (this.readyState === XHRStates.CONNECTING) {
            const openEvent = new CustomEvent("open");
            this.dispatchEvent(openEvent);
            this._setReadyState(XHRStates.OPEN);
        }
        const data = this.xhr.responseText.substring(this.progress);
        this.progress += data.length;
        data.split(/(\r\n|\r|\n){2}/g).forEach((part) => {
            if (part.trim().length === 0) {
                const chunkEvent = this._parseEventChunk(this.chunk.trim());
                if (chunkEvent !== null) {
                    this.dispatchEvent(chunkEvent);
                    this.chunk = "";
                }
            }
            else {
                this.chunk += part;
            }
        });
    }
    _onStreamLoaded(e) {
        this._onStreamProgress(e);
        const streamData = this._parseEventChunk(this.chunk);
        if (streamData !== null) {
            // Parse the last chunk.
            this.dispatchEvent(streamData);
            this.chunk = "";
        }
    }
    /**
     * Parse a received SSE event chunk into a constructed event object.
     */
    _parseEventChunk(chunk) {
        if (!chunk || !chunk.length) {
            return null;
        }
        const e = { id: null, retry: null, data: "", event: "message" };
        chunk.split(/\n|\r\n|\r/).forEach((line) => {
            line = line.trimEnd();
            const index = line.indexOf(FIELD_SEPARATOR);
            if (index <= 0) {
                // Line was either empty, or started with a separator and is a comment.
                // Either way, ignore.
                return;
            }
            const field = line.substring(0, index);
            if (!(field in e)) {
                return;
            }
            const value = line.substring(index + 1).trimLeft();
            if (field === "data") {
                e[field] += value;
            }
            else {
                e[field] = value;
            }
        });
        const event = new CustomEvent(e.event);
        event.data = e.data;
        event.id = e.id;
        return event;
    }
    _checkStreamClosed(e) {
        if (!this.xhr) {
            return;
        }
        if (this.xhr.readyState === XMLHttpRequest.DONE) {
            this._setReadyState(XHRStates.CLOSED);
        }
    }
}
exports.SSE = SSE;


/***/ })

}]);
//# sourceMappingURL=node_modules_hodlen_sse_ts_lib_index_js.854e7a4fb8191a802ca0.js.map