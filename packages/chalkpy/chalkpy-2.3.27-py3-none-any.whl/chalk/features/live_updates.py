from typing import Any, List, Tuple, Type

import cloudpickle

from chalk.utils import notebook
from chalk.utils.log_with_context import get_logger

_logger = get_logger(__name__)

NO_CLIENT_HELPTEXT = """A Chalk client has not yet been initialized in this notebook.
This means that you can create resolvers and features and test them locally, but
they will not be synced to Chalk's servers. To create a client, run the following
in your notebook:

>>> from chalk.client import ChalkClient
>>> client = ChalkClient(branch="my_branch_name")

This will create a Chalk connection pointed at the branch of your choice. New resolvers
or features that you create will be automatically uploaded to that branch. To create a
new branch, use the Chalk CLI:

$ chalk apply --branch my_branch_name
"""

NO_BRANCH_HELPTEXT = """The Chalk client on this notebook does not have a branch set.
Modifications to resolvers or features cannot be uploaded to Chalk until a branch is
specified. You can create a new branch via the Chalk CLI by running:

$ chalk apply --branch my_branch_name

Then, in Python you can point a Chalk client at an existing branch with the following code:

>>> from chalk.client import ChalkClient
>>> client = ChalkClient(branch="my_branch_name")
"""


def deploy_update(obj: Any):
    """
    If this code is being run in a Jupyter notebook, cloudpickle this
    object's dependencies and send it to the API server.
    """
    if notebook.is_defined_in_module(obj):
        # If resolver is defined in a module that's imported by a notebook, don't deploy it.
        # This is to avoid re-deploying every feature if customer imports their existing codebase into a notebook.
        return

    from chalk.parsed.duplicate_input_gql import GraphLogSeverity

    if len(errors := _validate_current_graph()) > 0:
        for err in errors:
            _logger.error(f"{err.severity}: {err.subheader}")
        if any(err.severity == GraphLogSeverity.ERROR for err in errors):
            _remove_object_from_registries(obj)
            raise ValueError(f"Failed to validate updated graph ({len(errors)} errors).")

    pickled_obj = cloudpickle.dumps(obj)
    from chalk.client.client_impl import ChalkAPIClientImpl

    client = ChalkAPIClientImpl._latest_client
    if client is None:
        raise RuntimeError(NO_CLIENT_HELPTEXT)
    if client._config.branch is None:
        raise RuntimeError(NO_BRANCH_HELPTEXT)

    try:
        resp = client._send_updated_entity(environment=None, pickled_entity=pickled_obj)
    except Exception as e:
        _logger.error(f"Failed to deploy '{obj.__name__}' to branch '{client._config.branch}' due to error: {e}")
    else:
        print(f"Deployed '{obj.__name__}' to branch '{client._config.branch}'")
        _print_response(resp)


def _print_response(resp: "UpdateGraphEntityResponse"):
    from chalk.client.models import SingleEntityUpdate, UpdateGraphEntityResponse

    if resp.errors:
        for e in resp.errors:
            _logger.error(e.message)
        return

    all_updated_objects: List[Tuple[str, SingleEntityUpdate]] = []
    all_updated_objects.extend(("+", o) for o in (resp.added or []))
    all_updated_objects.extend(("*", o) for o in (resp.modified or []))
    all_updated_objects.extend(("-", o) for o in (resp.removed or []))
    all_updated_objects.sort(key=lambda p: p[1].entity_fqn)
    for update_char, update_resp in all_updated_objects:
        print(f"{update_char}\t{update_resp.entity_type}: {update_resp.entity_fqn}")


def _validate_current_graph() -> List["UpdateGraphError"]:
    # TODO figure out circular imports
    from chalk.features import unwrap_feature
    from chalk.features.feature_set import FeatureSetBase
    from chalk.features.resolver import Resolver
    from chalk.parsed._graph_validation import validate_graph
    from chalk.parsed.duplicate_input_gql import UpsertGraphGQL
    from chalk.parsed.json_conversions import convert_type_to_gql

    resolvers = [convert_type_to_gql(r) for r in Resolver.registry]
    features = []
    for fs in FeatureSetBase.registry.values():
        all_features = [f for f in fs.features if not f.is_autogenerated]
        deduped_features = list({unwrap_feature(f).fqn: f for f in all_features}.values())
        features.extend(convert_type_to_gql(f) for f in deduped_features)
    graph_gql = UpsertGraphGQL(
        resolvers=resolvers,
        features=features,
        # TODO
        config=None,  # load_project_config()
    )
    return validate_graph(graph_gql)


def _remove_object_from_registries(obj: Any):
    """
    If an object fails validation and we keep it registered, all future resolvers/features will cause validation to fail as well.
    """
    from chalk.features.feature_set import FeatureSetBase, is_features_cls
    from chalk.features.resolver import Resolver

    if isinstance(obj, Resolver):
        obj.registry.remove(obj)
    elif is_features_cls(obj):
        FeatureSetBase.registry.pop(obj.namespace)
    else:
        raise ValueError(f"Can't remove object from registry, unrecognized type: {obj}")


def register_live_updates_if_in_notebook(cls: Type):
    if notebook.is_notebook():
        setattr(cls, "hook", deploy_update)
