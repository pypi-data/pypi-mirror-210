# -*- coding: utf-8 -*-

"""
oceanxbridgeplatformapis

This file was automatically generated by APIMATIC v3.0 (
 https://www.apimatic.io ).
"""
from oceanxbridgeplatformapis.api_helper import APIHelper
from oceanxbridgeplatformapis.models.component_option import ComponentOption


class ShipmentComponent(object):

    """Implementation of the 'shipmentComponent' model.

    TODO: type model description here.

    Attributes:
        component (string): The individual product code that is required to
            assemble the parent product code.
        component_name (string): TODO: type description here.
        component_qty (int): The quantity requested for an individual product
            code that is required to assemble the parent product code.
        component_unit_price (float): The individual product code price.
            Normally a percentage of the parent product codeâ€™s sale price
        component_unit_sales_tax (float): TODO: type description here.
        component_unit_sh (float): TODO: type description here.
        component_unit_total_price (float): TODO: type description here.
        oms_line_number (string): The Order Management's line number
            associated individual product code.
        not_shippable (bool): Used to indicate if the product code will be
            physically shipped out to the customer. Note - If this flag is
            already setup within the OceanX Bridge Platfrom in the Product
            master, the flag sent in the this Shipment request will overright
            that configuration.
        print_invoice (bool): Use to indicate if the product code should be
            printed on the customer facing invoice notice. Note - If this flag
            is already setup within the OceanX Bridge Platfrom in the Product
            master, the flag sent in the this Shipment request will overright
            that configuration.
        post_ship_confirm_line (bool): Use to indicate whether this product
            code will be reported back to the client's system when shipment
            confirmations are posted back. Note - If this flag is already
            setup within the OceanX Bridge Platfrom in the Product master, the
            flag sent in the this Shipment request will overright that
            configuration.
        component_options (list of ComponentOption): TODO: type description
            here.

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "component": 'component',
        "component_qty": 'componentQty',
        "component_name": 'componentName',
        "component_unit_price": 'componentUnitPrice',
        "component_unit_sales_tax": 'componentUnitSalesTax',
        "component_unit_sh": 'componentUnitSH',
        "component_unit_total_price": 'componentUnitTotalPrice',
        "oms_line_number": 'omsLineNumber',
        "not_shippable": 'notShippable',
        "print_invoice": 'printInvoice',
        "post_ship_confirm_line": 'postShipConfirmLine',
        "component_options": 'componentOptions'
    }

    _optionals = [
        'component_name',
        'component_unit_price',
        'component_unit_sales_tax',
        'component_unit_sh',
        'component_unit_total_price',
        'oms_line_number',
        'not_shippable',
        'print_invoice',
        'post_ship_confirm_line',
        'component_options',
    ]

    def __init__(self,
                 component=None,
                 component_qty=None,
                 component_name=APIHelper.SKIP,
                 component_unit_price=APIHelper.SKIP,
                 component_unit_sales_tax=APIHelper.SKIP,
                 component_unit_sh=APIHelper.SKIP,
                 component_unit_total_price=APIHelper.SKIP,
                 oms_line_number=APIHelper.SKIP,
                 not_shippable=APIHelper.SKIP,
                 print_invoice=APIHelper.SKIP,
                 post_ship_confirm_line=APIHelper.SKIP,
                 component_options=APIHelper.SKIP):
        """Constructor for the ShipmentComponent class"""

        # Initialize members of the class
        self.component = component 
        if component_name is not APIHelper.SKIP:
            self.component_name = component_name 
        self.component_qty = component_qty 
        if component_unit_price is not APIHelper.SKIP:
            self.component_unit_price = component_unit_price 
        if component_unit_sales_tax is not APIHelper.SKIP:
            self.component_unit_sales_tax = component_unit_sales_tax 
        if component_unit_sh is not APIHelper.SKIP:
            self.component_unit_sh = component_unit_sh 
        if component_unit_total_price is not APIHelper.SKIP:
            self.component_unit_total_price = component_unit_total_price 
        if oms_line_number is not APIHelper.SKIP:
            self.oms_line_number = oms_line_number 
        if not_shippable is not APIHelper.SKIP:
            self.not_shippable = not_shippable 
        if print_invoice is not APIHelper.SKIP:
            self.print_invoice = print_invoice 
        if post_ship_confirm_line is not APIHelper.SKIP:
            self.post_ship_confirm_line = post_ship_confirm_line 
        if component_options is not APIHelper.SKIP:
            self.component_options = component_options 

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Creates an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """
        if dictionary is None:
            return None

        # Extract variables from the dictionary

        component = dictionary.get("component") if dictionary.get("component") else None
        component_qty = dictionary.get("componentQty") if dictionary.get("componentQty") else None
        component_name = dictionary.get("componentName") if dictionary.get("componentName") else APIHelper.SKIP
        component_unit_price = dictionary.get("componentUnitPrice") if dictionary.get("componentUnitPrice") else APIHelper.SKIP
        component_unit_sales_tax = dictionary.get("componentUnitSalesTax") if dictionary.get("componentUnitSalesTax") else APIHelper.SKIP
        component_unit_sh = dictionary.get("componentUnitSH") if dictionary.get("componentUnitSH") else APIHelper.SKIP
        component_unit_total_price = dictionary.get("componentUnitTotalPrice") if dictionary.get("componentUnitTotalPrice") else APIHelper.SKIP
        oms_line_number = dictionary.get("omsLineNumber") if dictionary.get("omsLineNumber") else APIHelper.SKIP
        not_shippable = dictionary.get("notShippable") if "notShippable" in dictionary.keys() else APIHelper.SKIP
        print_invoice = dictionary.get("printInvoice") if "printInvoice" in dictionary.keys() else APIHelper.SKIP
        post_ship_confirm_line = dictionary.get("postShipConfirmLine") if "postShipConfirmLine" in dictionary.keys() else APIHelper.SKIP
        component_options = None
        if dictionary.get('componentOptions') is not None:
            component_options = [ComponentOption.from_dictionary(x) for x in dictionary.get('componentOptions')]
        else:
            component_options = APIHelper.SKIP
        # Return an object of this model
        return cls(component,
                   component_qty,
                   component_name,
                   component_unit_price,
                   component_unit_sales_tax,
                   component_unit_sh,
                   component_unit_total_price,
                   oms_line_number,
                   not_shippable,
                   print_invoice,
                   post_ship_confirm_line,
                   component_options)
