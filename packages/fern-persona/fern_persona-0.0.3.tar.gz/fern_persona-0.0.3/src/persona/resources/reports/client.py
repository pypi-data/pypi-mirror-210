# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

import httpx
import pydantic

from ...core.api_error import ApiError
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_headers import remove_none_from_headers
from ...environment import PersonaEnvironment
from ...errors.bad_request_error import BadRequestError
from ...types.business_lookup_report_1_request_data import BusinessLookupReport1RequestData
from ...types.business_lookup_report_1_response import BusinessLookupReport1Response
from ...types.create_a_report_request_data import CreateAReportRequestData
from ...types.dismiss_matches_request_data import DismissMatchesRequestData
from ...types.dismiss_matches_response import DismissMatchesResponse
from ...types.redact_a_report_response import RedactAReportResponse
from ...types.report_action_pause_continuous_monitoring_response import ReportActionPauseContinuousMonitoringResponse
from ...types.report_action_re_run_report_response import ReportActionReRunReportResponse
from ...types.report_action_resume_continuous_monitoring_response import ReportActionResumeContinuousMonitoringResponse
from ...types.reports_add_a_tag_request_meta import ReportsAddATagRequestMeta
from ...types.reports_add_a_tag_response import ReportsAddATagResponse
from ...types.reports_remove_a_tag_request_meta import ReportsRemoveATagRequestMeta
from ...types.reports_remove_a_tag_response import ReportsRemoveATagResponse
from ...types.reports_set_all_tags_request_meta import ReportsSetAllTagsRequestMeta
from ...types.reports_set_all_tags_response import ReportsSetAllTagsResponse
from ...types.retrieve_a_report_response import RetrieveAReportResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class ReportsClient:
    def __init__(self, *, environment: PersonaEnvironment = PersonaEnvironment.DEFAULT, api_key: str):
        self._environment = environment
        self.api_key = api_key

    def retrieve_a_report(
        self, report_id: str, *, key_inflection: typing.Optional[str] = None
    ) -> RetrieveAReportResponse:
        _response = httpx.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment.value}/", f"reports/{report_id}"),
            headers=remove_none_from_headers(
                {"Key-Inflection": key_inflection, "Authorization": f"Bearer  {self.api_key}"}
            ),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RetrieveAReportResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def redact_a_report(self, report_id: str, *, persona_version: typing.Optional[str] = None) -> RedactAReportResponse:
        _response = httpx.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._environment.value}/", f"reports/{report_id}"),
            headers=remove_none_from_headers(
                {"Persona-Version": persona_version, "Authorization": f"Bearer  {self.api_key}"}
            ),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RedactAReportResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_all_reports(
        self,
        *,
        page_before: typing.Optional[str] = None,
        page_after: typing.Optional[str] = None,
        page_size: typing.Optional[str] = None,
        filter_reference_id: typing.Optional[str] = None,
        filter_account_id: typing.Optional[str] = None,
        key_inflection: typing.Optional[str] = None,
    ) -> None:
        _response = httpx.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment.value}/", "reports"),
            params={
                "page[before]": page_before,
                "page[after]": page_after,
                "page[size]": page_size,
                "filter[reference-id]": filter_reference_id,
                "filter[account-id]": filter_account_id,
            },
            headers=remove_none_from_headers(
                {"Key-Inflection": key_inflection, "Authorization": f"Bearer  {self.api_key}"}
            ),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_a_report(self, *, data: CreateAReportRequestData, key_inflection: typing.Optional[str] = None) -> None:
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", "reports"),
            json=jsonable_encoder({"data": data}),
            headers=remove_none_from_headers(
                {"Key-Inflection": key_inflection, "Authorization": f"Bearer  {self.api_key}"}
            ),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def print_report_pdf(self, report_id: str) -> None:
        _response = httpx.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment.value}/", f"reports/{report_id}/print"),
            headers=remove_none_from_headers({"Authorization": f"Bearer  {self.api_key}"}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def business_lookup_report_1(
        self, *, data: typing.Optional[BusinessLookupReport1RequestData] = OMIT
    ) -> BusinessLookupReport1Response:
        _request: typing.Dict[str, typing.Any] = {}
        if data is not OMIT:
            _request["data"] = data
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", "reports/biz-lookup"),
            json=jsonable_encoder(_request),
            headers=remove_none_from_headers({"Authorization": f"Bearer  {self.api_key}"}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(BusinessLookupReport1Response, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def add_a_tag(
        self,
        report_id: str,
        *,
        meta: typing.Optional[ReportsAddATagRequestMeta] = OMIT,
        key_inflection: typing.Optional[str] = None,
        idempotency_key: typing.Optional[str] = None,
    ) -> ReportsAddATagResponse:
        _request: typing.Dict[str, typing.Any] = {}
        if meta is not OMIT:
            _request["meta"] = meta
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", f"reports/{report_id}/add-tag"),
            json=jsonable_encoder(_request),
            headers=remove_none_from_headers(
                {
                    "Key-Inflection": key_inflection,
                    "Idempotency-Key": idempotency_key,
                    "Authorization": f"Bearer  {self.api_key}",
                }
            ),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ReportsAddATagResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def remove_a_tag(
        self,
        report_id: str,
        *,
        meta: typing.Optional[ReportsRemoveATagRequestMeta] = OMIT,
        key_inflection: typing.Optional[str] = None,
        idempotency_key: typing.Optional[str] = None,
    ) -> ReportsRemoveATagResponse:
        _request: typing.Dict[str, typing.Any] = {}
        if meta is not OMIT:
            _request["meta"] = meta
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", f"reports/{report_id}/remove-tag"),
            json=jsonable_encoder(_request),
            headers=remove_none_from_headers(
                {
                    "Key-Inflection": key_inflection,
                    "Idempotency-Key": idempotency_key,
                    "Authorization": f"Bearer  {self.api_key}",
                }
            ),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ReportsRemoveATagResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def set_all_tags(
        self,
        report_id: str,
        *,
        meta: typing.Optional[ReportsSetAllTagsRequestMeta] = OMIT,
        key_inflection: typing.Optional[str] = None,
        idempotency_key: typing.Optional[str] = None,
    ) -> ReportsSetAllTagsResponse:
        _request: typing.Dict[str, typing.Any] = {}
        if meta is not OMIT:
            _request["meta"] = meta
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", f"reports/{report_id}/set-tags"),
            json=jsonable_encoder(_request),
            headers=remove_none_from_headers(
                {
                    "Key-Inflection": key_inflection,
                    "Idempotency-Key": idempotency_key,
                    "Authorization": f"Bearer  {self.api_key}",
                }
            ),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ReportsSetAllTagsResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def report_action_re_run_report(self, report_id: str) -> ReportActionReRunReportResponse:
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", f"reports/{report_id}/run"),
            headers=remove_none_from_headers({"Authorization": f"Bearer  {self.api_key}"}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ReportActionReRunReportResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def dismiss_matches(
        self,
        report_id: str,
        *,
        data: DismissMatchesRequestData,
        key_inflection: typing.Optional[str] = None,
        idempotency_key: typing.Optional[str] = None,
    ) -> DismissMatchesResponse:
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", f"reports/{report_id}/dismiss"),
            json=jsonable_encoder({"data": data}),
            headers=remove_none_from_headers(
                {
                    "Key-Inflection": key_inflection,
                    "Idempotency-Key": idempotency_key,
                    "Authorization": f"Bearer  {self.api_key}",
                }
            ),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DismissMatchesResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def report_action_resume_continuous_monitoring(
        self, report_id: str
    ) -> ReportActionResumeContinuousMonitoringResponse:
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", f"reports/{report_id}/resume"),
            headers=remove_none_from_headers({"Authorization": f"Bearer  {self.api_key}"}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ReportActionResumeContinuousMonitoringResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def report_action_pause_continuous_monitoring(
        self, report_id: str
    ) -> ReportActionPauseContinuousMonitoringResponse:
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", f"reports/{report_id}/pause"),
            headers=remove_none_from_headers({"Authorization": f"Bearer  {self.api_key}"}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ReportActionPauseContinuousMonitoringResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncReportsClient:
    def __init__(self, *, environment: PersonaEnvironment = PersonaEnvironment.DEFAULT, api_key: str):
        self._environment = environment
        self.api_key = api_key

    async def retrieve_a_report(
        self, report_id: str, *, key_inflection: typing.Optional[str] = None
    ) -> RetrieveAReportResponse:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "GET",
                urllib.parse.urljoin(f"{self._environment.value}/", f"reports/{report_id}"),
                headers=remove_none_from_headers(
                    {"Key-Inflection": key_inflection, "Authorization": f"Bearer  {self.api_key}"}
                ),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RetrieveAReportResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def redact_a_report(
        self, report_id: str, *, persona_version: typing.Optional[str] = None
    ) -> RedactAReportResponse:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "DELETE",
                urllib.parse.urljoin(f"{self._environment.value}/", f"reports/{report_id}"),
                headers=remove_none_from_headers(
                    {"Persona-Version": persona_version, "Authorization": f"Bearer  {self.api_key}"}
                ),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RedactAReportResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_all_reports(
        self,
        *,
        page_before: typing.Optional[str] = None,
        page_after: typing.Optional[str] = None,
        page_size: typing.Optional[str] = None,
        filter_reference_id: typing.Optional[str] = None,
        filter_account_id: typing.Optional[str] = None,
        key_inflection: typing.Optional[str] = None,
    ) -> None:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "GET",
                urllib.parse.urljoin(f"{self._environment.value}/", "reports"),
                params={
                    "page[before]": page_before,
                    "page[after]": page_after,
                    "page[size]": page_size,
                    "filter[reference-id]": filter_reference_id,
                    "filter[account-id]": filter_account_id,
                },
                headers=remove_none_from_headers(
                    {"Key-Inflection": key_inflection, "Authorization": f"Bearer  {self.api_key}"}
                ),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_a_report(
        self, *, data: CreateAReportRequestData, key_inflection: typing.Optional[str] = None
    ) -> None:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", "reports"),
                json=jsonable_encoder({"data": data}),
                headers=remove_none_from_headers(
                    {"Key-Inflection": key_inflection, "Authorization": f"Bearer  {self.api_key}"}
                ),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def print_report_pdf(self, report_id: str) -> None:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "GET",
                urllib.parse.urljoin(f"{self._environment.value}/", f"reports/{report_id}/print"),
                headers=remove_none_from_headers({"Authorization": f"Bearer  {self.api_key}"}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def business_lookup_report_1(
        self, *, data: typing.Optional[BusinessLookupReport1RequestData] = OMIT
    ) -> BusinessLookupReport1Response:
        _request: typing.Dict[str, typing.Any] = {}
        if data is not OMIT:
            _request["data"] = data
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", "reports/biz-lookup"),
                json=jsonable_encoder(_request),
                headers=remove_none_from_headers({"Authorization": f"Bearer  {self.api_key}"}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(BusinessLookupReport1Response, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def add_a_tag(
        self,
        report_id: str,
        *,
        meta: typing.Optional[ReportsAddATagRequestMeta] = OMIT,
        key_inflection: typing.Optional[str] = None,
        idempotency_key: typing.Optional[str] = None,
    ) -> ReportsAddATagResponse:
        _request: typing.Dict[str, typing.Any] = {}
        if meta is not OMIT:
            _request["meta"] = meta
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", f"reports/{report_id}/add-tag"),
                json=jsonable_encoder(_request),
                headers=remove_none_from_headers(
                    {
                        "Key-Inflection": key_inflection,
                        "Idempotency-Key": idempotency_key,
                        "Authorization": f"Bearer  {self.api_key}",
                    }
                ),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ReportsAddATagResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def remove_a_tag(
        self,
        report_id: str,
        *,
        meta: typing.Optional[ReportsRemoveATagRequestMeta] = OMIT,
        key_inflection: typing.Optional[str] = None,
        idempotency_key: typing.Optional[str] = None,
    ) -> ReportsRemoveATagResponse:
        _request: typing.Dict[str, typing.Any] = {}
        if meta is not OMIT:
            _request["meta"] = meta
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", f"reports/{report_id}/remove-tag"),
                json=jsonable_encoder(_request),
                headers=remove_none_from_headers(
                    {
                        "Key-Inflection": key_inflection,
                        "Idempotency-Key": idempotency_key,
                        "Authorization": f"Bearer  {self.api_key}",
                    }
                ),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ReportsRemoveATagResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def set_all_tags(
        self,
        report_id: str,
        *,
        meta: typing.Optional[ReportsSetAllTagsRequestMeta] = OMIT,
        key_inflection: typing.Optional[str] = None,
        idempotency_key: typing.Optional[str] = None,
    ) -> ReportsSetAllTagsResponse:
        _request: typing.Dict[str, typing.Any] = {}
        if meta is not OMIT:
            _request["meta"] = meta
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", f"reports/{report_id}/set-tags"),
                json=jsonable_encoder(_request),
                headers=remove_none_from_headers(
                    {
                        "Key-Inflection": key_inflection,
                        "Idempotency-Key": idempotency_key,
                        "Authorization": f"Bearer  {self.api_key}",
                    }
                ),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ReportsSetAllTagsResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def report_action_re_run_report(self, report_id: str) -> ReportActionReRunReportResponse:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", f"reports/{report_id}/run"),
                headers=remove_none_from_headers({"Authorization": f"Bearer  {self.api_key}"}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ReportActionReRunReportResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def dismiss_matches(
        self,
        report_id: str,
        *,
        data: DismissMatchesRequestData,
        key_inflection: typing.Optional[str] = None,
        idempotency_key: typing.Optional[str] = None,
    ) -> DismissMatchesResponse:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", f"reports/{report_id}/dismiss"),
                json=jsonable_encoder({"data": data}),
                headers=remove_none_from_headers(
                    {
                        "Key-Inflection": key_inflection,
                        "Idempotency-Key": idempotency_key,
                        "Authorization": f"Bearer  {self.api_key}",
                    }
                ),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DismissMatchesResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def report_action_resume_continuous_monitoring(
        self, report_id: str
    ) -> ReportActionResumeContinuousMonitoringResponse:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", f"reports/{report_id}/resume"),
                headers=remove_none_from_headers({"Authorization": f"Bearer  {self.api_key}"}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ReportActionResumeContinuousMonitoringResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def report_action_pause_continuous_monitoring(
        self, report_id: str
    ) -> ReportActionPauseContinuousMonitoringResponse:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", f"reports/{report_id}/pause"),
                headers=remove_none_from_headers({"Authorization": f"Bearer  {self.api_key}"}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ReportActionPauseContinuousMonitoringResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
