# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

import httpx
import pydantic

from ...core.api_error import ApiError
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_headers import remove_none_from_headers
from ...environment import PersonaEnvironment
from ...errors.bad_request_error import BadRequestError
from ...types.import_an_account_request_data import ImportAnAccountRequestData
from ...types.import_an_account_response import ImportAnAccountResponse
from ...types.import_email_address_lists_request_data import ImportEmailAddressListsRequestData
from ...types.import_email_address_lists_response import ImportEmailAddressListsResponse
from ...types.import_face_lists_request_data import ImportFaceListsRequestData
from ...types.import_face_lists_response import ImportFaceListsResponse
from ...types.import_geolocation_lists_request_data import ImportGeolocationListsRequestData
from ...types.import_geolocation_lists_response import ImportGeolocationListsResponse
from ...types.import_government_id_number_lists_request_data import ImportGovernmentIdNumberListsRequestData
from ...types.import_government_id_number_lists_response import ImportGovernmentIdNumberListsResponse
from ...types.import_ip_address_lists_request_data import ImportIpAddressListsRequestData
from ...types.import_ip_address_lists_response import ImportIpAddressListsResponse
from ...types.import_name_lists_request_data import ImportNameListsRequestData
from ...types.import_name_lists_response import ImportNameListsResponse
from ...types.import_phone_number_lists_request_data import ImportPhoneNumberListsRequestData
from ...types.import_phone_number_lists_response import ImportPhoneNumberListsResponse
from ...types.retrieve_an_importer_response import RetrieveAnImporterResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class ImportersClient:
    def __init__(self, *, environment: PersonaEnvironment = PersonaEnvironment.DEFAULT, api_key: str):
        self._environment = environment
        self.api_key = api_key

    def retrieve_an_importer(self, importer_id: str) -> RetrieveAnImporterResponse:
        _response = httpx.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment.value}/", f"importers/{importer_id}"),
            headers=remove_none_from_headers({"Authorization": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RetrieveAnImporterResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def import_an_account(self, *, data: typing.Optional[ImportAnAccountRequestData] = OMIT) -> ImportAnAccountResponse:
        _request: typing.Dict[str, typing.Any] = {}
        if data is not OMIT:
            _request["data"] = data
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", "importer/accounts"),
            json=jsonable_encoder(_request),
            headers=remove_none_from_headers({"Authorization": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ImportAnAccountResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def import_email_address_lists(
        self, *, data: typing.Optional[ImportEmailAddressListsRequestData] = OMIT
    ) -> ImportEmailAddressListsResponse:
        _request: typing.Dict[str, typing.Any] = {}
        if data is not OMIT:
            _request["data"] = data
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", "importer/list-item/email-addresses"),
            json=jsonable_encoder(_request),
            headers=remove_none_from_headers({"Authorization": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ImportEmailAddressListsResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def import_geolocation_lists(
        self, *, data: typing.Optional[ImportGeolocationListsRequestData] = OMIT
    ) -> ImportGeolocationListsResponse:
        _request: typing.Dict[str, typing.Any] = {}
        if data is not OMIT:
            _request["data"] = data
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", "importer/list-item/geolocations"),
            json=jsonable_encoder(_request),
            headers=remove_none_from_headers({"Authorization": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ImportGeolocationListsResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def import_government_id_number_lists(
        self, *, data: typing.Optional[ImportGovernmentIdNumberListsRequestData] = OMIT
    ) -> ImportGovernmentIdNumberListsResponse:
        _request: typing.Dict[str, typing.Any] = {}
        if data is not OMIT:
            _request["data"] = data
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", "importer/list-item/government-id-numbers"),
            json=jsonable_encoder(_request),
            headers=remove_none_from_headers({"Authorization": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ImportGovernmentIdNumberListsResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def import_ip_address_lists(
        self, *, data: typing.Optional[ImportIpAddressListsRequestData] = OMIT
    ) -> ImportIpAddressListsResponse:
        _request: typing.Dict[str, typing.Any] = {}
        if data is not OMIT:
            _request["data"] = data
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", "importer/list-item/ip-addresses"),
            json=jsonable_encoder(_request),
            headers=remove_none_from_headers({"Authorization": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ImportIpAddressListsResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def import_name_lists(self, *, data: typing.Optional[ImportNameListsRequestData] = OMIT) -> ImportNameListsResponse:
        _request: typing.Dict[str, typing.Any] = {}
        if data is not OMIT:
            _request["data"] = data
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", "importer/list-item/names"),
            json=jsonable_encoder(_request),
            headers=remove_none_from_headers({"Authorization": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ImportNameListsResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def import_phone_number_lists(
        self, *, data: typing.Optional[ImportPhoneNumberListsRequestData] = OMIT
    ) -> ImportPhoneNumberListsResponse:
        _request: typing.Dict[str, typing.Any] = {}
        if data is not OMIT:
            _request["data"] = data
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", "importer/list-item/phone-numbers"),
            json=jsonable_encoder(_request),
            headers=remove_none_from_headers({"Authorization": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ImportPhoneNumberListsResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def import_face_lists(self, *, data: typing.Optional[ImportFaceListsRequestData] = OMIT) -> ImportFaceListsResponse:
        _request: typing.Dict[str, typing.Any] = {}
        if data is not OMIT:
            _request["data"] = data
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", "importer/list-item/faces"),
            json=jsonable_encoder(_request),
            headers=remove_none_from_headers({"Authorization": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ImportFaceListsResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncImportersClient:
    def __init__(self, *, environment: PersonaEnvironment = PersonaEnvironment.DEFAULT, api_key: str):
        self._environment = environment
        self.api_key = api_key

    async def retrieve_an_importer(self, importer_id: str) -> RetrieveAnImporterResponse:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "GET",
                urllib.parse.urljoin(f"{self._environment.value}/", f"importers/{importer_id}"),
                headers=remove_none_from_headers({"Authorization": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RetrieveAnImporterResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def import_an_account(
        self, *, data: typing.Optional[ImportAnAccountRequestData] = OMIT
    ) -> ImportAnAccountResponse:
        _request: typing.Dict[str, typing.Any] = {}
        if data is not OMIT:
            _request["data"] = data
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", "importer/accounts"),
                json=jsonable_encoder(_request),
                headers=remove_none_from_headers({"Authorization": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ImportAnAccountResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def import_email_address_lists(
        self, *, data: typing.Optional[ImportEmailAddressListsRequestData] = OMIT
    ) -> ImportEmailAddressListsResponse:
        _request: typing.Dict[str, typing.Any] = {}
        if data is not OMIT:
            _request["data"] = data
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", "importer/list-item/email-addresses"),
                json=jsonable_encoder(_request),
                headers=remove_none_from_headers({"Authorization": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ImportEmailAddressListsResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def import_geolocation_lists(
        self, *, data: typing.Optional[ImportGeolocationListsRequestData] = OMIT
    ) -> ImportGeolocationListsResponse:
        _request: typing.Dict[str, typing.Any] = {}
        if data is not OMIT:
            _request["data"] = data
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", "importer/list-item/geolocations"),
                json=jsonable_encoder(_request),
                headers=remove_none_from_headers({"Authorization": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ImportGeolocationListsResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def import_government_id_number_lists(
        self, *, data: typing.Optional[ImportGovernmentIdNumberListsRequestData] = OMIT
    ) -> ImportGovernmentIdNumberListsResponse:
        _request: typing.Dict[str, typing.Any] = {}
        if data is not OMIT:
            _request["data"] = data
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", "importer/list-item/government-id-numbers"),
                json=jsonable_encoder(_request),
                headers=remove_none_from_headers({"Authorization": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ImportGovernmentIdNumberListsResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def import_ip_address_lists(
        self, *, data: typing.Optional[ImportIpAddressListsRequestData] = OMIT
    ) -> ImportIpAddressListsResponse:
        _request: typing.Dict[str, typing.Any] = {}
        if data is not OMIT:
            _request["data"] = data
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", "importer/list-item/ip-addresses"),
                json=jsonable_encoder(_request),
                headers=remove_none_from_headers({"Authorization": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ImportIpAddressListsResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def import_name_lists(
        self, *, data: typing.Optional[ImportNameListsRequestData] = OMIT
    ) -> ImportNameListsResponse:
        _request: typing.Dict[str, typing.Any] = {}
        if data is not OMIT:
            _request["data"] = data
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", "importer/list-item/names"),
                json=jsonable_encoder(_request),
                headers=remove_none_from_headers({"Authorization": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ImportNameListsResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def import_phone_number_lists(
        self, *, data: typing.Optional[ImportPhoneNumberListsRequestData] = OMIT
    ) -> ImportPhoneNumberListsResponse:
        _request: typing.Dict[str, typing.Any] = {}
        if data is not OMIT:
            _request["data"] = data
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", "importer/list-item/phone-numbers"),
                json=jsonable_encoder(_request),
                headers=remove_none_from_headers({"Authorization": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ImportPhoneNumberListsResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def import_face_lists(
        self, *, data: typing.Optional[ImportFaceListsRequestData] = OMIT
    ) -> ImportFaceListsResponse:
        _request: typing.Dict[str, typing.Any] = {}
        if data is not OMIT:
            _request["data"] = data
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", "importer/list-item/faces"),
                json=jsonable_encoder(_request),
                headers=remove_none_from_headers({"Authorization": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ImportFaceListsResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
