# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_events.ipynb.

# %% auto 0
__all__ = ['getEvents']

# %% ../nbs/04_events.ipynb 3
import numpy as np
from matplotlib import pyplot as plt
import seaborn as sns

# %% ../nbs/04_events.ipynb 11
# Process data
def getEvents(data: np.ndarray, # Single-channel data; 1 x t array
              samplerate: int, # Recording sample rate (Hz)
              eventIDs: list = None # List of unique event IDs
             )->np.ndarray: # Event timings; n x t array
    '''
    Recover discrete event timings from single-channel data
    '''
    
    # If no event IDs defined, use defaults
    if eventIDs is None:
       eventIDs = [5, 10, 15, 20] # Set default event IDs (start, end, event1, event2)
    
    # Get pulse widths
    pulsewidths = np.array(eventIDs)
    pulsewidths = pulsewidths * 10 # Convert to ms

    # Get number of events
    num_events = len(eventIDs)

    # Create empty array - n x t
    events = np.zeros((num_events, len(data)))

    # Define threshold - 0.75x max value
    threshold = 0.75 * np.max(data)

    # Define cutoffs - in number of samples; expect high 5ms before, low 5ms after expected end
    cutoffs = ((pulsewidths - 5)/1000) * samplerate # Point 5ms before expected end of pulse

    # Sort cutoffs in descending order and get sorted order
    cutoffs_sorted = np.sort(cutoffs) 
    cutoffs_sorted = cutoffs_sorted[::-1]
    cutoffs_args = np.argsort(cutoffs)
    cutoffs_args = cutoffs_args[::-1]

    # Loop over points in data array
    idx = 0
    while idx < len(data):
        # Get current datapoint
        d = data[idx]

        # If point > threshold: find next point below threshold
        if d > threshold:
            # Reset state
            window = 1
            end_found = False

            # Continue until value drops below threshold or data ends
            while (idx + window <= len(data) and end_found == False):
                # Check if dropped below threshold
                if data[idx + window] < threshold:
                    end_found = True

                window += 1

            # If end found: assign to event type
            if end_found:
                # Iterate over sorted cutoffs
                event_assigned = False # Avoid assigning to multiple events
                for cutoff_id, cutoff in enumerate(cutoffs_sorted):
                    # If greater than expected, assign to event type (unsorted)
                    if window > cutoff and event_assigned == False:
                        events[cutoffs_args[cutoff_id], idx] = 1
                        event_assigned = True

                # Move current point to end of window
                idx = idx + window

        # Move to next datapoint
        idx += 1
        
    # Return events list
    return events
