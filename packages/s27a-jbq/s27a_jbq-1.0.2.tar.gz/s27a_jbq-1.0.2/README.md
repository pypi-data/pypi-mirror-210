# 精班棋

![](https://img.shields.io/badge/release-1.0.2-blue)
![](https://img.shields.io/badge/last%20commit-may-yellow)
![](https://img.shields.io/badge/license-MIT-green)

精班棋是一款自由度很高的棋类游戏

这款游戏的最大特点就是地图的可自定义性以及对于扩展插件的高度支持

运用这些，你可以在精班棋中还原出一些经典的棋类游戏

# 目录

- [精班棋](#精班棋)
- [目录](#目录)
- [安装](#安装)
- [使用方法](#使用方法)
- [许可证](#许可证)

# 安装

[(返回目录)](#目录)

您可以在[精班棋官网](https://amf14151.github.io/JBQ/)下载exe版本并获取对应的地图、扩展包，也可以按照下面的步骤安装模块并使用

## 安装模块

*若想通过模块的方式运行精班棋，您需要Python解释器*

使用以下命令来安装模块

```
python.exe -m pip install s27a_jbq
```

在安装`s27a_jbq`模块后，使用以下命令来构建游戏文件夹

```
python.exe -m s27a_jbq generate_game {游戏文件夹路径} {游戏运行方式}
```

其中，游戏运行方式有以下选择：

- `window`：窗口模式

示例：

```
python.exe -m s27a_jbq generate_game C:/JBQ window
```

上方的代码在C盘根目录中创建名为`JBQ`的游戏文件夹

您也可以在建立文件夹后直接使用以下代码构建主文件（不推荐）

``` python
from s27a_jbq.game import App

def main():
   app = App()
   app.run()
```

在游戏文件夹中有`extensions`文件夹，该文件夹用于存储扩展，扩展具体使用方法请看[这里](#扩展)

# 使用方法

[(返回目录)](#目录)

## 游戏过程

在设置好地图及扩展（具体方法请参见下文）后，点击开始游戏即可

游戏中，以红方为先手，双方依次移动棋子并尝试吃掉对方棋子，以先吃掉对方的首领棋子（任意1个即可）为胜利条件

每个棋子上会有可移动方向标注，在己方回合单击棋子即可查看该棋子具体可移动格子，右键棋子可以查看该棋子详细信息

一些棋子在不同的位置会有不同的可移动格子，每个棋子的具体可移动格子根据地图、扩展决定

在对局结束后，如果在设置中设置了棋局记录路径，则会对棋局进行记录

## 地图

地图文件是`.xlsx`文件，其中包含至少3个表，分别对应棋子、棋盘与特殊规则

地图文件中可能会有其他名称的表，这些表不会被程序读取，但内部可能会有该地图的说明信息

您可以在[这里](https://github.com/amf14151/s27a_jbq/tree/main/map)下载地图，也可以自定义地图

下文介绍了地图文件的构造以及自定义地图的方法

### 棋盘构造

行坐标轴（纵轴）为`x`，列坐标轴（横轴）为`y`

自左上至右下坐标轴编号**由1递增**，自右下至左上坐标轴编号**由-1递减**

在进行下表编写时均以**红方棋盘**为正向

### 棋子表

棋子表的名称为`chesses`

棋子表中会有一些通用的语法规则，规则如下：

1. 棋盘位置规则

   - 单个棋盘位置规则表示为`M[a|b|c]`的形式，其中`M`为规则名，为大写，`a`、`b`、`c`等为参数，为整数，用`|`隔开
   - 可使用的规则名：
     - `X[m|n|...]`，当棋子所在的行数等于任意一个参数（`m`、`n`等）时，该规则的值为`true`，否则为`false`
     - `Y[m|n|...]`，当棋子所在的列数等于任意一个参数（`m`、`n`等）时，该规则的值为`true`，否则为`false`
     - `P[x1|y1|x2|y2|...]`，当棋子所在的位置等于`(xn,yn)`时，该规则的值为`true`，否则为`false`
   - 其他规则名返回值为`false`
   - 多个棋盘位置规则间用`&`连接（`&`表示**或**，即棋子位置只要有一项满足该棋盘位置规则则返回值为`true`）
   - 示例：`X[1|-1]&Y[1|-1]`表示棋盘边缘区域

2. 可移动规则

   - 该语法规则分为两部分，第一部分为可以向某方向移动一格，第二部分为可以向某方向移动无限格。两部分语法相同，两部分间用`;`隔开
   - 在每一部分中，用`,`分隔开所有可移动方向，这些方向按**左上、上、右上、左、右、左下、下、右下**分别对应1-8
   - 如果这一方向上是否可以移动有位置限制，可以在方向编号后加上`()`，并在内部填入*棋盘位置规则*
   - 在第二部分中出现的可移动方向可以不出现在第一部分中
   - 如果没有第二部分（或第一部分）也需要在后面（或前面）加上`;`
   - 示例：`1(Y[4|5|6]),3(Y[2|3|4]),4(Y[7]),5(Y[1]);2`

棋子表的每一列内容依次是`编号`、`名称`、`归属`、`首领`、`可移动`、`升变条件`、`升变后可移动`、`其他`

这些内容必须**按序**排列，具体填写规则如下：

1. 编号

   - 每个棋子独立的不同的编号
   - 按照顺序由1递增

2. 名称

   - 可以重复
   - 长度尽量**小于等于3**
   - 当名称为纯数字时需用`"`包裹

3. 归属
   
   - 红方为1，蓝方为2，中立为3
   - 中立棋子双方都可以移动，但既不能吃子也不能被吃

4. 首领

   - 默认值为空，如果某棋子是首领则需要填入`c`
   - 首领数量不限，但每方至少需要1个（否则将无法结束游戏）

5. 可移动
   
   - 填入*可移动规则*

6. 升变条件

   - 填入*棋盘位置规则*，默认值为空，即不启用升变
   - 当棋子位置符合升变条件时，其可移动规则永久变为*升变后可移动*

7. 升变后可移动

   - 填入*可移动规则*
   - 该角色无法升变时仍需填写`;`

8. 其他

   - 可以有多列，每列标题、填写规则由扩展而定

### 棋盘表

棋盘表的名称为`map`

棋盘表由两部分组成：棋盘行列数、棋盘布局

棋盘行列数在表的第一行，格式如下：

```
行  [填写总行数]  列  [填写总列数]
```

棋盘布局自第二行起，每格填写对应棋子编号，空位不填

### 特殊规则表

特殊规则表为提前预定格式，每项特殊规则默认不启用，如果启用则需要填入`c`

特殊规则介绍：

- 启用升变：一些棋子在达成某些条件后会升变，获得更强的移动方式
- 启用悔棋：在对方走出下一步前可以悔棋（仅限单人模式）
- 限制连续3步以上移动中立棋子：一方连续移动中立棋子的步数达到3次时本回合将不能继续移动中立棋子，该规则对于所有中立棋子通用

## 扩展

扩展是`.py`文件，是用`Python`语言按照一定规则编写的一段代码块

运用扩展可以实现一些独特的行走方法及游戏规则

### 获取及导入

您可以在[这里](https://github.com/amf14151/s27a_jbq/tree/main/extensions)获取扩展，也可以自行编写扩展

在游戏设置中可以导入扩展，也可以手动将扩展文件添加到游戏文件夹下的`extensions`文件夹下

扩展默认为禁用状态，可以在游戏设置中启用或禁用扩展

### 编写扩展

扩展可以自行编写。在每个扩展文件中都定义了一些名称固定的函数或方法，这些函数或方法将会在游戏周期中的某一指定时刻进行调用以改变游戏状态

#### 数据类型

下面列出了扩展文件中可能会作为参数的特殊数据类型

- 棋子类

   ``` python
   class Chess:
      self.id # 棋子编号
      self.name # 棋子名称
      self.belong # 棋子归属
      self.is_captain # 棋子是否为首领
      self.is_tran # 棋子是否已升变
   ```

#### 接口

扩展接口如下：

- 对局信息

   ``` python
   JBQ.turn
   ```
   `int`值。当前回合，1为红方，2为蓝方

   ``` python
   JBQ.win(belong:int) # 胜利
   JBQ.stalemate() # 和棋
   ```
   函数。`win`中`belong`为`int`值

- 棋盘行列

   ``` python
   JBQ.rl # 棋盘行数
   JBQ.cl # 棋盘列数
   ```
   `int`值。为当前棋盘的行数或列数

- 方向距离计算

   ``` python
   JBQ.get_arr_by_rd(arr:tuple[int,int],r:int,d:int)
   ```
   函数。传入参数`arr`为二元组`(i,j)`，依次为棋盘的行数、列数（以`0`起始），`r`相对于`arr`的方向（1-8，参见上文），`d`为相对于`arr`的距离；返回值为二元组，若超出棋盘范围则返回`None`

- 占据情况

   ``` python
   JBQ.get_chess_by_arr(arr:tuple[int,int])
   ```
   函数。传入参数`arr`为二元组，依次为棋盘的行数、列数；返回值为`Chess`对象或`None`

- 棋子位置

   ``` python
   JBQ.get_chess_arr_by_id(id:int)
   ```
   函数。传入参数`id`为`int`值，是棋子的编号；返回值为二元组，依次为棋子所在的行数、列数。当场上有多个该编号的棋子或无该编号的棋子时返回值为`None`

- 移动棋子

   ``` python
   JBQ.move(arr1:tuple[int,int],arr2:tuple[int,int])
   ```
   函数。传入参数有两个。都为二元组，第一个参数表示要移动的棋子所在位置，第二个参数表示该棋子要移动到的位置。该移动不会再次调用扩展`after_move`函数

#### 具体函数

1. 棋盘位置规则函数

   ``` python
   def loc_func(args:tuple[int],arr:tuple[int,int]):
      ...
      return False
   ```

   - 在触发*棋盘位置规则*时触发相对应的函数
   - 传入参数有两个。`args`参数即对应*棋盘位置规则*中的参数；`arr`参数是触发该*棋盘位置规则*的棋子的位置（同上）
   - 返回值为`bool`值，代表该规则触发与否

2. `check_can_go`函数

   ``` python
   def check_can_go(can_go:list[list[tuple[int,int]]],chess,arr:tuple[int,int]):
      ...
      return list[tuple[int,int]](...)
   ```

   - 在每颗棋子被选择时触发相对应的函数，修改该棋子的`can_go`列表
   - 传入参数有三个。`can_go`参数为二维列表，列表每一项表示一个可行走组（如可行走无限格中的一列），项中的二元组表示原来能走的格子；`chess`参数是棋子本身，可以调用棋子相关的API
   - 返回值为`bool`值，代表该规则触发与否
   - 注意：此处修改`can_go`的扩展顺序以扩展导入顺序为准

3. `after_move`函数

   ``` python
   def after_move(arr1:tuple[int,int],arr2:tuple[int,int]):
      ...
   ```

   - 行走后触发相对应的函数
   - 传入参数有两个。都为二元组，第一个参数表示移动的棋子所在位置，第二个参数表示该棋子移动到的位置

#### 构造

扩展文件由以下几部分组成：

- `EX_NAME`：`str`值，内容为扩展名称，必填
- `EX_VERSION`：`str`值，内容为扩展版本，必填
- `loc_rules`：字典，键为`str`值，内容为棋盘位置规则名称，值为函数，内容为对应的棋盘位置规则函数
- `check_can_go`：函数
- `after_move`：函数

# 许可证

[(返回目录)](#目录)

[MIT License](https://github.com/amf14151/s27a_jbq/blob/main/LICENSE)
