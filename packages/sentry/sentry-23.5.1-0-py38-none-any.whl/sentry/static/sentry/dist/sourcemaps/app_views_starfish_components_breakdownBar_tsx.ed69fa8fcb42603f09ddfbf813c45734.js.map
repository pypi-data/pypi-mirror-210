{"version":3,"file":"chunks/app_views_starfish_components_breakdownBar_tsx.xxxxxxxxxxxxxxxxxxxx.js","mappings":"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","sources":["webpack:///./app/views/starfish/views/webServiceView/webServiceBreakdownChart.tsx","webpack:///./app/views/starfish/components/breakdownBar.tsx","webpack:///./app/views/starfish/views/webServiceView/queries.js"],"sourcesContent":["import {useTheme} from '@emotion/react';\nimport styled from '@emotion/styled';\nimport moment from 'moment';\n\nimport _EventsRequest from 'sentry/components/charts/eventsRequest';\nimport {t} from 'sentry/locale';\nimport {space} from 'sentry/styles/space';\nimport {Series} from 'sentry/types/echarts';\nimport usePageFilters from 'sentry/utils/usePageFilters';\nimport {getSegmentLabel} from 'sentry/views/starfish/components/breakdownBar';\nimport Chart from 'sentry/views/starfish/components/chart';\nimport ChartPanel from 'sentry/views/starfish/components/chartPanel';\nimport {PERIOD_REGEX} from 'sentry/views/starfish/utils/dates';\nimport {zeroFillSeries} from 'sentry/views/starfish/utils/zeroFillSeries';\n\nexport function WebServiceBreakdownChart({\n  segments,\n  isTopDataLoading,\n  topData,\n  isOtherDataLoading,\n  otherData,\n  cumulativeSummary,\n}) {\n  const pageFilter = usePageFilters();\n  const theme = useTheme();\n  const seriesByDomain: {[module: string]: Series} = {};\n  const [_, num, unit] = pageFilter.selection.datetime.period?.match(PERIOD_REGEX) ?? [];\n  const start =\n    num && unit\n      ? moment().subtract(num, unit as 'h' | 'd')\n      : moment(pageFilter.selection.datetime.start);\n  const end = moment(pageFilter.selection.datetime.end ?? undefined);\n\n  if (!isTopDataLoading && !isOtherDataLoading && segments.length > 0) {\n    segments.forEach(segment => {\n      const label = getSegmentLabel(\n        segment.span_operation,\n        segment.action,\n        segment.domain\n      );\n      seriesByDomain[label] = {\n        seriesName: `${label}`,\n        data: [],\n      };\n    });\n\n    topData.forEach(value => {\n      seriesByDomain[\n        getSegmentLabel(value.span_operation, value.action, value.domain)\n      ].data.push({value: value.p75, name: value.interval});\n    });\n\n    seriesByDomain.Other = {\n      seriesName: `Other`,\n      data: [],\n    };\n\n    otherData.forEach(value => {\n      seriesByDomain.Other.data.push({value: value.p75, name: value.interval});\n    });\n  }\n  const data = Object.values(seriesByDomain).map(series =>\n    zeroFillSeries(series, moment.duration(1, 'day'), start, end)\n  );\n\n  return (\n    <ChartPanel title={t('Duration breakdown (p50)')}>\n      <Container>\n        <Chart\n          statsPeriod=\"24h\"\n          height={350}\n          data={data}\n          start=\"\"\n          end=\"\"\n          loading={isTopDataLoading}\n          utc={false}\n          grid={{\n            left: '0',\n            right: '0',\n            top: '16px',\n            bottom: '8px',\n          }}\n          definedAxisTicks={4}\n          stacked\n          chartColors={theme.charts.getColorPalette(5)}\n        />\n        {cumulativeSummary}\n      </Container>\n    </ChartPanel>\n  );\n}\n\nconst Container = styled('div')`\n  display: grid;\n  grid-auto-flow: column;\n  grid-auto-columns: 1fr min-content;\n  align-items: center;\n  justify-self: flex-end;\n  gap: ${space(2)};\n`;\n","import {Fragment, useState} from 'react';\nimport {Link} from 'react-router';\nimport isPropValid from '@emotion/is-prop-valid';\nimport {useTheme} from '@emotion/react';\nimport styled from '@emotion/styled';\nimport {motion} from 'framer-motion';\nimport * as qs from 'query-string';\n\nimport Truncate from 'sentry/components/truncate';\nimport {t} from 'sentry/locale';\nimport {space} from 'sentry/styles/space';\nimport {percent} from 'sentry/utils';\nimport {getUtcDateString} from 'sentry/utils/dates';\nimport {useQuery} from 'sentry/utils/queryClient';\nimport usePageFilters from 'sentry/utils/usePageFilters';\nimport {\n  getOtherDomainsActionsAndOpTimeseries,\n  getTopDomainsActionsAndOp,\n  getTopDomainsActionsAndOpTimeseries,\n  totalCumulativeTime,\n} from 'sentry/views/starfish/views/webServiceView/queries';\nimport {WebServiceBreakdownChart} from 'sentry/views/starfish/views/webServiceView/webServiceBreakdownChart';\n\nconst HOST = 'http://localhost:8080';\n\ntype ModuleSegment = {\n  action: string;\n  domain: string;\n  module: string;\n  num_spans: number;\n  span_operation: string;\n  sum: number;\n};\ntype Props = {\n  title: string;\n  transaction?: string;\n};\n\nexport function getSegmentLabel(span_operation, action, domain) {\n  if (span_operation === 'http.client') {\n    return t('%s requests to %s', action, domain);\n  }\n  if (span_operation === 'db') {\n    return t('%s queries on %s', action, domain);\n  }\n  return span_operation || domain || undefined;\n}\n\nexport function getSegmentLabelForTable(span_operation, action, domain) {\n  const label = getSegmentLabel(span_operation, action, domain);\n  if (span_operation === 'http.client') {\n    return t('%s (http.client spans)', label);\n  }\n  if (span_operation === 'db') {\n    return t('%s (db spans)', label);\n  }\n  return t('%s spans', label);\n}\n\nfunction getNumSpansLabel(segment) {\n  if (segment.span_operation === 'other' && segment.num_spans === 0) {\n    return t('Other');\n  }\n  if (segment.num_spans && segment.module && segment.module !== 'none') {\n    return t('%s %s spans', segment.num_spans, segment.module);\n  }\n  return t('%s spans', segment.num_spans);\n}\n\nfunction getGroupingLabel(segment) {\n  if (segment.module === 'http') {\n    return t('Action: %s, Host: %s', segment.action, segment.domain);\n  }\n  if (segment.module === 'db') {\n    return t('Action: %s, Table: %s', segment.action, segment.domain);\n  }\n  if (segment.module !== 'other') {\n    return t('Operation: %s', segment.span_operation);\n  }\n  return '';\n}\n\nfunction FacetBreakdownBar({transaction: maybeTransaction}: Props) {\n  const theme = useTheme();\n  const {selection} = usePageFilters();\n  const [hoveredValue, setHoveredValue] = useState<ModuleSegment | null>(null);\n\n  const transaction = maybeTransaction ?? '';\n\n  const {data: segments} = useQuery({\n    queryKey: ['webServiceSpanGrouping', transaction, selection.datetime],\n    queryFn: () =>\n      fetch(\n        `${HOST}/?query=${getTopDomainsActionsAndOp({\n          transaction,\n          datetime: selection.datetime,\n        })}`\n      ).then(res => res.json()),\n    retry: false,\n    initialData: [],\n  });\n\n  const {data: cumulativeTime} = useQuery({\n    queryKey: ['totalCumulativeTime', transaction, selection.datetime],\n    queryFn: () =>\n      fetch(\n        `${HOST}/?query=${totalCumulativeTime({\n          transaction,\n          datetime: selection.datetime,\n        })}`\n      ).then(res => res.json()),\n    retry: false,\n    initialData: [],\n  });\n\n  const totalValues = cumulativeTime.reduce((acc, segment) => acc + segment.sum, 0);\n  const totalSegments = segments.reduce((acc, segment) => acc + segment.sum, 0);\n  const otherValue = totalValues - totalSegments;\n  const otherSegment = {\n    span_operation: 'other',\n    sum: otherValue,\n    action: '',\n    domain: '',\n    num_spans: 0,\n    module: 'other',\n  } as ModuleSegment;\n\n  let topConditions =\n    segments.length > 0\n      ? ` (span_operation = '${segments[0].span_operation}' ${\n          segments[0].action ? `AND action = '${segments[0].action}'` : ''\n        } ${segments[0].domain ? `AND domain = '${segments[0].domain}'` : ''})`\n      : '';\n\n  for (let index = 1; index < segments.length; index++) {\n    const element = segments[index];\n    topConditions = topConditions.concat(\n      ' OR ',\n      `(span_operation = '${element.span_operation}' ${\n        element.action ? `AND action = '${element.action}'` : ''\n      } ${element.domain ? `AND domain = '${element.domain}'` : ''})`\n    );\n  }\n\n  const {isLoading: isTopDataLoading, data: topData} = useQuery({\n    queryKey: ['topSpanGroupTimeseries', transaction, topConditions, selection.datetime],\n    queryFn: () =>\n      fetch(\n        `${HOST}/?query=${getTopDomainsActionsAndOpTimeseries({\n          transaction,\n          topConditions,\n          datetime: selection.datetime,\n        })}`\n      ).then(res => res.json()),\n    retry: false,\n    initialData: [],\n  });\n\n  const {isLoading: isOtherDataLoading, data: otherData} = useQuery({\n    queryKey: [\n      'otherSpanGroupTimeseries',\n      transaction,\n      topConditions,\n      selection.datetime,\n    ],\n    queryFn: () =>\n      fetch(\n        `${HOST}/?query=${getOtherDomainsActionsAndOpTimeseries({\n          transaction,\n          topConditions,\n          datetime: selection.datetime,\n        })}`\n      ).then(res => res.json()),\n    retry: false,\n    initialData: [],\n  });\n\n  const legendColors = theme.charts.getColorPalette(5);\n\n  function renderLegend() {\n    return (\n      <LegendAnimateContainer expanded animate={{height: '100%', opacity: 1}}>\n        <LegendContainer>\n          {[...segments, otherSegment].map((segment, index) => {\n            const pctLabel = Math.floor(percent(segment.sum, totalValues));\n            const unfocus = !!hoveredValue && hoveredValue !== segment;\n            const focus = hoveredValue === segment;\n            const label = getSegmentLabel(\n              segment.span_operation,\n              segment.action,\n              segment.domain\n            );\n            const numSpansLabel = getNumSpansLabel(segment);\n            const groupingLabel = getGroupingLabel(segment);\n            const {start, end, utc, period} = selection.datetime;\n            const spansLinkQueryParams =\n              start && end\n                ? {start: getUtcDateString(start), end: getUtcDateString(end), utc}\n                : {statsPeriod: period};\n            ['span_operation', 'action', 'domain'].forEach(key => {\n              if (segment[key] !== undefined && segment[key] !== null) {\n                spansLinkQueryParams[key] = segment[key];\n              }\n            });\n\n            const spansLink =\n              segment.module === 'other'\n                ? `/starfish/spans/`\n                : `/starfish/spans/?${qs.stringify(spansLinkQueryParams)}`;\n\n            return (\n              <li key={`segment-${label}-${index}`}>\n                <Link to={spansLink}>\n                  <div\n                    onMouseOver={() => setHoveredValue(segment)}\n                    onMouseLeave={() => setHoveredValue(null)}\n                    onClick={() => {}}\n                  >\n                    <LegendRow>\n                      <LegendDot color={legendColors[index]} focus={focus} />\n                      <LegendText unfocus={unfocus}>\n                        {numSpansLabel ?? (\n                          <NotApplicableLabel>{t('n/a')}</NotApplicableLabel>\n                        )}\n                      </LegendText>\n                      <LegendPercent unfocus={unfocus}>{`${pctLabel}%`}</LegendPercent>\n                    </LegendRow>\n                    <SpanGroupingText color={legendColors[index]} unfocus={unfocus}>\n                      <SpanGroupLabelTruncate value={groupingLabel} maxLength={40} />\n                    </SpanGroupingText>\n                  </div>\n                </Link>\n              </li>\n            );\n          })}\n        </LegendContainer>\n      </LegendAnimateContainer>\n    );\n  }\n\n  const cumulativeSummary = <TagSummary>{renderLegend()}</TagSummary>;\n\n  return (\n    <Fragment>\n      <WebServiceBreakdownChart\n        segments={segments}\n        isTopDataLoading={isTopDataLoading}\n        topData={topData}\n        isOtherDataLoading={isOtherDataLoading}\n        otherData={otherData}\n        cumulativeSummary={cumulativeSummary}\n      />\n    </Fragment>\n  );\n}\n\nexport default FacetBreakdownBar;\n\nconst TagSummary = styled('div')`\n  margin-bottom: ${space(2)};\n`;\n\nconst LegendAnimateContainer = styled(motion.div, {\n  shouldForwardProp: prop =>\n    prop === 'animate' || (prop !== 'expanded' && isPropValid(prop)),\n})<{expanded: boolean}>`\n  height: 0;\n  opacity: 0;\n  ${p => (!p.expanded ? 'overflow: hidden;' : '')}\n`;\n\nconst LegendContainer = styled('ol')`\n  list-style: none;\n  padding: 0;\n  margin: ${space(1)} 0;\n`;\n\nconst LegendRow = styled('div')`\n  display: flex;\n  align-items: center;\n  cursor: pointer;\n`;\n\nconst SpanGroupingText = styled('div')<{\n  color: string;\n  unfocus: boolean;\n}>`\n  display: flex;\n  align-items: center;\n  cursor: pointer;\n  padding: 0 0 ${space(1)} 0;\n  color: ${p => p.color};\n  opacity: ${p => (p.unfocus ? '0.6' : '1')};\n`;\n\nconst LegendDot = styled('span')<{color: string; focus: boolean}>`\n  padding: 0;\n  position: relative;\n  width: 11px;\n  height: 11px;\n  text-indent: -9999em;\n  display: inline-block;\n  border-radius: 50%;\n  flex-shrink: 0;\n  background-color: ${p => p.color};\n  &:after {\n    content: '';\n    border-radius: 50%;\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    outline: ${p => p.theme.gray100} ${space(0.5)} solid;\n    opacity: ${p => (p.focus ? '1' : '0')};\n    transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n  }\n`;\n\nconst LegendText = styled('span')<{unfocus: boolean}>`\n  margin-left: ${space(1)};\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  transition: color 0.3s;\n  color: ${p => (p.unfocus ? p.theme.gray300 : p.theme.gray400)};\n`;\n\nconst LegendPercent = styled('span')<{unfocus: boolean}>`\n  margin-left: ${space(1)};\n  color: ${p => (p.unfocus ? p.theme.gray300 : p.theme.gray400)};\n  text-align: right;\n  flex-grow: 1;\n`;\n\nconst NotApplicableLabel = styled('span')`\n  color: ${p => p.theme.gray300};\n`;\n\nexport const SpanGroupLabelTruncate = styled(Truncate)`\n  white-space: nowrap;\n`;\n","import {datetimeToClickhouseFilterTimestamps} from 'sentry/views/starfish/utils/dates';\n\nexport const getModuleBreakdown = ({transaction}) => {\n  return `SELECT\n  sum(exclusive_time) as sum, module\n  FROM spans_experimental_starfish\n  WHERE module != 'none'\n  ${transaction ? `AND transaction = '${transaction}'` : ''}\n  GROUP BY module\n  ORDER BY -sum\n `;\n};\n\nexport const getTopDomainsActionsAndOp = ({transaction, datetime}) => {\n  const {start_timestamp, end_timestamp} = datetimeToClickhouseFilterTimestamps(datetime);\n  return `SELECT domain, action, span_operation, module, sum(exclusive_time) as sum, uniq(description) as num_spans\n   FROM spans_experimental_starfish\n   WHERE span_operation NOT IN ['base.dispatch.execute', 'middleware.django', 'base.dispatch.request']\n   ${transaction ? `AND transaction = '${transaction}'` : ''}\n   ${start_timestamp ? `AND greaterOrEquals(start_timestamp, '${start_timestamp}')` : ''}\n   ${end_timestamp ? `AND lessOrEquals(start_timestamp, '${end_timestamp}')` : ''}\n   GROUP BY domain, action, span_operation, module\n   ORDER BY -sum(exclusive_time)\n   LIMIT 5\n `;\n};\n\nexport const getTopDomainsActionsAndOpTimeseries = ({\n  transaction,\n  topConditions,\n  datetime,\n}) => {\n  const {start_timestamp, end_timestamp} = datetimeToClickhouseFilterTimestamps(datetime);\n  return `SELECT\n quantile(0.75)(exclusive_time) as p75, domain, action, span_operation, module,\n toStartOfInterval(start_timestamp, INTERVAL 12 HOUR) as interval\n FROM default.spans_experimental_starfish\n WHERE greaterOrEquals(start_timestamp, '${start_timestamp}')\n ${end_timestamp ? `AND lessOrEquals(start_timestamp, '${end_timestamp}')` : ''}\n ${topConditions ? `AND (${topConditions})` : ''}\n ${transaction ? `AND transaction = '${transaction}'` : ''}\n GROUP BY interval, domain, action, span_operation, module\n ORDER BY interval, domain, action, span_operation, module\n `;\n};\n\nexport const getOtherDomainsActionsAndOpTimeseries = ({\n  transaction,\n  topConditions,\n  datetime,\n}) => {\n  const {start_timestamp, end_timestamp} = datetimeToClickhouseFilterTimestamps(datetime);\n  return `SELECT\n quantile(0.75)(exclusive_time) as p75,\n toStartOfInterval(start_timestamp, INTERVAL 12 HOUR) as interval\n FROM default.spans_experimental_starfish\n WHERE greaterOrEquals(start_timestamp, '${start_timestamp}')\n ${end_timestamp ? `AND lessOrEquals(start_timestamp, '${end_timestamp}')` : ''}\n ${topConditions ? `AND NOT (${topConditions})` : ''}\n ${transaction ? `AND transaction = '${transaction}'` : ''}\n GROUP BY interval\n ORDER BY interval\n `;\n};\n\nexport const spanThroughput = ({transaction}) => {\n  return `SELECT\n  count() as count,\n  toStartOfInterval(start_timestamp, INTERVAL 12 HOUR) as interval\n  FROM default.spans_experimental_starfish\n  ${transaction ? `WHERE transaction = '${transaction}'` : ''}\n  GROUP BY interval\n  ORDER BY interval\n  `;\n};\n\nexport const totalCumulativeTime = ({transaction, datetime}) => {\n  const {start_timestamp, end_timestamp} = datetimeToClickhouseFilterTimestamps(datetime);\n  return `SELECT sum(exclusive_time) as sum\n   FROM spans_experimental_starfish\n   WHERE greaterOrEquals(start_timestamp, '${start_timestamp}')\n   ${end_timestamp ? `AND lessOrEquals(start_timestamp, '${end_timestamp}')` : ''}\n   ${transaction ? `AND transaction = '${transaction}'` : ''}\n `;\n};\n\nexport const getTopDomainsAndMethods = ({transaction}) => {\n  return `SELECT domain, action\n   FROM spans_experimental_starfish\n   WHERE span_operation = 'http.client'\n   ${transaction ? `AND transaction = '${transaction}'` : ''}\n   GROUP BY domain, action\n   ORDER BY -sum(exclusive_time)\n   LIMIT 5\n `;\n};\n\nexport const getTopHttpDomains = ({transaction}) => {\n  return `SELECT\n quantile(0.75)(exclusive_time) as p75, domain,\n toStartOfInterval(start_timestamp, INTERVAL 12 HOUR) as interval\n FROM default.spans_experimental_starfish\n WHERE domain IN (\n  SELECT domain\n   FROM spans_experimental_starfish\n   WHERE startsWith(span_operation, 'http')\n   ${transaction ? `AND transaction = '${transaction}'` : ''}\n   GROUP BY domain\n   ORDER BY -sum(exclusive_time)\n   LIMIT 2\n ) AND startsWith(span_operation, 'http')\n ${transaction ? `AND transaction = '${transaction}'` : ''}\n GROUP BY interval, domain\n ORDER BY interval, domain\n `;\n};\n\nexport const getOtherDomains = ({transaction}) => {\n  return `SELECT\n  quantile(0.75)(exclusive_time) as p75,\n  toStartOfInterval(start_timestamp, INTERVAL 12 HOUR) as interval\n  FROM default.spans_experimental_starfish\n  WHERE domain NOT IN (\n   SELECT domain\n    FROM spans_experimental_starfish\n    WHERE startsWith(span_operation, 'http')\n    ${transaction ? `AND transaction = '${transaction}'` : ''}\n    GROUP BY domain\n    ORDER BY -sum(exclusive_time)\n    LIMIT 2\n  ) AND startsWith(span_operation, 'http')\n  ${transaction ? `AND transaction = '${transaction}'` : ''}\n  GROUP BY interval\n  ORDER BY interval\n  `;\n};\n\nexport const getDatabaseTimeSpent = ({transaction}) => {\n  return `SELECT\n  quantile(0.75)(exclusive_time) as p75,\n  toStartOfInterval(start_timestamp, INTERVAL 12 HOUR) as interval\n  FROM default.spans_experimental_starfish\n  WHERE startsWith(span_operation, 'db') and span_operation != 'db.redis'\n  ${transaction ? `AND transaction = '${transaction}'` : ''}\n  GROUP BY interval\n  ORDER BY interval\n  `;\n};\n\nexport const getDbThroughput = ({transaction}) => {\n  return `SELECT\n  count() as count,\n  toStartOfInterval(start_timestamp, INTERVAL 12 HOUR) as interval\n  FROM default.spans_experimental_starfish\n  WHERE module = 'db'\n  ${transaction ? `AND transaction = '${transaction}'` : ''}\n  GROUP BY interval\n  ORDER BY interval\n  `;\n};\n\nexport const getHttpThroughput = ({transaction}) => {\n  return `SELECT\n  count() as count,\n  toStartOfInterval(start_timestamp, INTERVAL 12 HOUR) as interval\n  FROM default.spans_experimental_starfish\n  WHERE module = 'http'\n  ${transaction ? `AND transaction = '${transaction}'` : ''}\n  GROUP BY interval\n  ORDER BY interval\n `;\n};\n\nexport const FAILURE_RATE_QUERY = `SELECT\n toStartOfInterval(start_timestamp, INTERVAL 5 MINUTE) as interval,\n countIf(greaterOrEquals(status, 200) AND less(status, 300)) as successCount,\n countIf(greaterOrEquals(status, 500)) as failureCount,\n divide(failureCount, plus(successCount, failureCount)) as failureRate\n FROM spans_experimental_starfish\n WHERE module = 'http'\n GROUP BY interval\n ORDER BY interval asc\n `;\n"],"names":["WebServiceBreakdownChart","_ref","segments","isTopDataLoading","topData","isOtherDataLoading","otherData","cumulativeSummary","pageFilter","usePageFilters","theme","useTheme","seriesByDomain","_","num","unit","selection","datetime","period","match","PERIOD_REGEX","start","moment","subtract","end","undefined","length","forEach","segment","label","getSegmentLabel","span_operation","action","domain","seriesName","data","value","push","p75","name","interval","Other","Object","values","map","series","zeroFillSeries","_jsx","ChartPanel","title","t","children","_jsxs","Container","Chart","statsPeriod","height","loading","utc","grid","left","right","top","bottom","definedAxisTicks","stacked","chartColors","charts","getColorPalette","displayName","_styled","target","space","getSegmentLabelForTable","getTopDomainsActionsAndOp","_ref2","transaction","start_timestamp","end_timestamp","datetimeToClickhouseFilterTimestamps","getTopDomainsActionsAndOpTimeseries","_ref3","topConditions","getOtherDomainsActionsAndOpTimeseries","_ref4","totalCumulativeTime","_ref6"],"sourceRoot":""}