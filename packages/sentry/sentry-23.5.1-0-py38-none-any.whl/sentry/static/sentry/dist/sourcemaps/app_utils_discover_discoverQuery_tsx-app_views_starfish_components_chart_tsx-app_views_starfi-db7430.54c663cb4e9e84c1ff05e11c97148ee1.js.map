{"version":3,"file":"chunks/app_utils_discover_discoverQuery_tsx-app_views_starfish_components_chart_tsx-app_views_starfi-db7430.xxxxxxxxxxxxxxxxxxxx.js","mappings":"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","sources":["webpack:///./app/components/charts/areaChart.tsx","webpack:///./app/components/charts/series/areaSeries.tsx","webpack:///./app/components/charts/components/dataZoomSlider.tsx","webpack:///./app/components/charts/chartZoom.tsx","webpack:///./app/components/charts/components/dataZoomInside.tsx","webpack:///./app/components/charts/components/toolBox.tsx","webpack:///./app/utils/discover/discoverQuery.tsx","webpack:///./app/components/charts/series/scatterSeries.tsx","webpack:///./app/views/starfish/components/chart.tsx","webpack:///./app/views/starfish/components/chartPanel.tsx","webpack:///./app/views/starfish/utils/dates.tsx","webpack:///./app/views/starfish/utils/zeroFillSeries.tsx"],"sourcesContent":["import type {LineSeriesOption} from 'echarts';\n\nimport {Series} from 'sentry/types/echarts';\n\nimport AreaSeries from './series/areaSeries';\nimport BaseChart from './baseChart';\n\ntype ChartProps = Omit<React.ComponentProps<typeof BaseChart>, 'css'>;\n\nexport type AreaChartSeries = Series & Omit<LineSeriesOption, 'data' | 'name'>;\n\nexport interface AreaChartProps extends Omit<ChartProps, 'series'> {\n  series: AreaChartSeries[];\n  additionalSeries?: LineSeriesOption[];\n  stacked?: boolean;\n}\n\nexport function AreaChart({series, stacked, colors, ...props}: AreaChartProps) {\n  return (\n    <BaseChart\n      {...props}\n      data-test-id=\"area-chart\"\n      colors={colors}\n      series={series.map(({seriesName, data, ...otherSeriesProps}, i) =>\n        AreaSeries({\n          stack: stacked ? 'area' : undefined,\n          name: seriesName,\n          data: data.map(({name, value}) => [name, value]),\n          lineStyle: {\n            color: colors?.[i],\n            opacity: 1,\n            width: 0.4,\n          },\n          areaStyle: {\n            color: colors?.[i],\n            opacity: 1.0,\n          },\n          animation: false,\n          animationThreshold: 1,\n          animationDuration: 0,\n          ...otherSeriesProps,\n        })\n      )}\n    />\n  );\n}\n","import type {LineSeriesOption} from 'echarts';\n\nimport LineSeries from 'sentry/components/charts/series/lineSeries';\n\nexport default function AreaSeries(props: LineSeriesOption = {}): LineSeriesOption {\n  return LineSeries({\n    ...props,\n  });\n}\n","import 'echarts/lib/component/dataZoomSlider';\n\nimport type {SliderDataZoomComponentOption} from 'echarts';\n\nconst DEFAULT: SliderDataZoomComponentOption = {\n  realtime: false,\n  showDetail: false,\n  left: 0,\n  right: 6,\n  bottom: 8,\n};\n\nexport default function DataZoomSlider(\n  props: SliderDataZoomComponentOption | SliderDataZoomComponentOption[]\n): SliderDataZoomComponentOption[] {\n  // `props` can be boolean, if so return default\n  if (!props || !Array.isArray(props)) {\n    const dataZoom = {\n      ...DEFAULT,\n      ...props,\n    };\n    return [dataZoom];\n  }\n\n  return props;\n}\n","import {Component} from 'react';\nimport {InjectedRouter} from 'react-router';\nimport type {\n  DataZoomComponentOption,\n  InsideDataZoomComponentOption,\n  ToolboxComponentOption,\n  XAXisComponentOption,\n} from 'echarts';\nimport moment from 'moment';\nimport * as qs from 'query-string';\n\nimport {updateDateTime} from 'sentry/actionCreators/pageFilters';\nimport DataZoomInside from 'sentry/components/charts/components/dataZoomInside';\nimport DataZoomSlider from 'sentry/components/charts/components/dataZoomSlider';\nimport ToolBox from 'sentry/components/charts/components/toolBox';\nimport {DateString} from 'sentry/types';\nimport {\n  EChartChartReadyHandler,\n  EChartDataZoomHandler,\n  EChartFinishedHandler,\n  EChartRestoreHandler,\n} from 'sentry/types/echarts';\nimport {callIfFunction} from 'sentry/utils/callIfFunction';\nimport {getUtcDateString, getUtcToLocalDateObject} from 'sentry/utils/dates';\n\nconst getDate = date =>\n  date ? moment.utc(date).format(moment.HTML5_FMT.DATETIME_LOCAL_SECONDS) : null;\n\ntype Period = {\n  end: DateString;\n  period: string | null;\n  start: DateString;\n};\n\nconst ZoomPropKeys = [\n  'period',\n  'xAxis',\n  'onChartReady',\n  'onDataZoom',\n  'onRestore',\n  'onFinished',\n] as const;\n\nexport type ZoomRenderProps = Pick<Props, (typeof ZoomPropKeys)[number]> & {\n  dataZoom?: DataZoomComponentOption[];\n  end?: Date;\n  isGroupedByDate?: boolean;\n  showTimeInTooltip?: boolean;\n  start?: Date;\n  toolBox?: ToolboxComponentOption;\n  utc?: boolean;\n};\n\ntype Props = {\n  children: (props: ZoomRenderProps) => React.ReactNode;\n  chartZoomOptions?: DataZoomComponentOption;\n  disabled?: boolean;\n  end?: DateString;\n  onChartReady?: EChartChartReadyHandler;\n  onDataZoom?: EChartDataZoomHandler;\n  onFinished?: EChartFinishedHandler;\n  onRestore?: EChartRestoreHandler;\n  onZoom?: (period: Period) => void;\n  period?: string | null;\n  router?: InjectedRouter;\n  showSlider?: boolean;\n  start?: DateString;\n  usePageDate?: boolean;\n  utc?: boolean | null;\n  xAxis?: XAXisComponentOption;\n  xAxisIndex?: number | number[];\n};\n\n/**\n * This is a very opinionated component that takes a render prop through `children`. It\n * will provide props to be passed to `BaseChart` to enable support of zooming without\n * eCharts' clunky zoom toolboxes.\n *\n * This also is very tightly coupled with the Global Selection Header. We can make it more\n * generic if need be in the future.\n */\nclass ChartZoom extends Component<Props> {\n  constructor(props: Props) {\n    super(props);\n\n    // Zoom history\n    this.history = [];\n\n    // Initialize current period instance state for zoom history\n    this.saveCurrentPeriod(props);\n  }\n\n  componentDidUpdate() {\n    if (this.props.disabled) {\n      return;\n    }\n\n    // When component updates, make sure we sync current period state\n    // for use in zoom history\n    this.saveCurrentPeriod(this.props);\n  }\n\n  history: Period[];\n  currentPeriod?: Period;\n  zooming: (() => void) | null = null;\n\n  /**\n   * Save current period state from period in props to be used\n   * in handling chart's zoom history state\n   */\n  saveCurrentPeriod = props => {\n    this.currentPeriod = {\n      period: props.period,\n      start: getDate(props.start),\n      end: getDate(props.end),\n    };\n  };\n\n  /**\n   * Sets the new period due to a zoom related action\n   *\n   * Saves the current period to an instance property so that we\n   * can control URL state when zoom history is being manipulated\n   * by the chart controls.\n   *\n   * Saves a callback function to be called after chart animation is completed\n   */\n  setPeriod = ({period, start, end}, saveHistory = false) => {\n    const {router, onZoom, usePageDate} = this.props;\n    const startFormatted = getDate(start);\n    const endFormatted = getDate(end);\n\n    // Save period so that we can revert back to it when using echarts \"back\" navigation\n    if (saveHistory) {\n      this.history.push(this.currentPeriod!);\n    }\n\n    // Callback to let parent component know zoom has changed\n    // This is required for some more perceived responsiveness since\n    // we delay updating URL state so that chart animation can finish\n    //\n    // Parent container can use this to change into a loading state before\n    // URL parameters are changed\n    onZoom?.({\n      period,\n      start: startFormatted,\n      end: endFormatted,\n    });\n\n    this.zooming = () => {\n      if (usePageDate && router) {\n        const newQuery = {\n          ...router.location.query,\n          pageStart: start ? getUtcDateString(start) : undefined,\n          pageEnd: end ? getUtcDateString(end) : undefined,\n          pageStatsPeriod: period ?? undefined,\n        };\n\n        // Only push new location if query params has changed because this will cause a heavy re-render\n        if (qs.stringify(newQuery) !== qs.stringify(router.location.query)) {\n          router.push({\n            pathname: router.location.pathname,\n            query: newQuery,\n          });\n        }\n      } else {\n        updateDateTime(\n          {\n            period,\n            start: startFormatted\n              ? getUtcToLocalDateObject(startFormatted)\n              : startFormatted,\n            end: endFormatted ? getUtcToLocalDateObject(endFormatted) : endFormatted,\n          },\n          router,\n          {skipDesyncUpdate: true}\n        );\n      }\n\n      this.saveCurrentPeriod({period, start, end});\n    };\n  };\n\n  /**\n   * Enable zoom immediately instead of having to toggle to zoom\n   */\n  handleChartReady = chart => {\n    this.props.onChartReady?.(chart);\n  };\n\n  /**\n   * Restores the chart to initial viewport/zoom level\n   *\n   * Updates URL state to reflect initial params\n   */\n  handleZoomRestore = (evt, chart) => {\n    if (!this.history.length) {\n      return;\n    }\n\n    this.setPeriod(this.history[0]);\n\n    // reset history\n    this.history = [];\n\n    this.props.onRestore?.(evt, chart);\n  };\n\n  handleDataZoom = (evt, chart) => {\n    const model = chart.getModel();\n    const {startValue, endValue} = model._payload.batch[0];\n\n    // if `rangeStart` and `rangeEnd` are null, then we are going back\n    if (startValue === null && endValue === null) {\n      const previousPeriod = this.history.pop();\n\n      if (!previousPeriod) {\n        return;\n      }\n\n      this.setPeriod(previousPeriod);\n    } else {\n      const start = moment.utc(startValue);\n\n      // Add a day so we go until the end of the day (e.g. next day at midnight)\n      const end = moment.utc(endValue);\n\n      this.setPeriod({period: null, start, end}, true);\n    }\n\n    this.props.onDataZoom?.(evt, chart);\n  };\n\n  /**\n   * Chart event when *any* rendering+animation finishes\n   *\n   * `this.zooming` acts as a callback function so that\n   * we can let the native zoom animation on the chart complete\n   * before we update URL state and re-render\n   */\n  handleChartFinished = (_props, chart) => {\n    if (typeof this.zooming === 'function') {\n      this.zooming();\n      this.zooming = null;\n    }\n\n    // This attempts to activate the area zoom toolbox feature\n    const zoom = chart._componentsViews?.find(c => c._features && c._features.dataZoom);\n    if (zoom && !zoom._features.dataZoom._isZoomActive) {\n      // Calling dispatchAction will re-trigger handleChartFinished\n      chart.dispatchAction({\n        type: 'takeGlobalCursor',\n        key: 'dataZoomSelect',\n        dataZoomSelectActive: true,\n      });\n    }\n\n    callIfFunction(this.props.onFinished);\n  };\n\n  render() {\n    const {\n      utc: _utc,\n      start: _start,\n      end: _end,\n      disabled,\n      children,\n      xAxisIndex,\n\n      router: _router,\n      onZoom: _onZoom,\n      onRestore: _onRestore,\n      onChartReady: _onChartReady,\n      onDataZoom: _onDataZoom,\n      onFinished: _onFinished,\n      showSlider,\n      chartZoomOptions,\n      ...props\n    } = this.props;\n\n    const utc = _utc ?? undefined;\n    const start = _start ? getUtcToLocalDateObject(_start) : undefined;\n    const end = _end ? getUtcToLocalDateObject(_end) : undefined;\n\n    if (disabled) {\n      return children({\n        utc,\n        start,\n        end,\n        ...props,\n      });\n    }\n    const renderProps = {\n      // Zooming only works when grouped by date\n      isGroupedByDate: true,\n      onChartReady: this.handleChartReady,\n      utc,\n      start,\n      end,\n      dataZoom: showSlider\n        ? [\n            ...DataZoomSlider({xAxisIndex, ...chartZoomOptions}),\n            ...DataZoomInside({\n              xAxisIndex,\n              ...(chartZoomOptions as InsideDataZoomComponentOption),\n            }),\n          ]\n        : DataZoomInside({\n            xAxisIndex,\n            ...(chartZoomOptions as InsideDataZoomComponentOption),\n          }),\n      showTimeInTooltip: true,\n      toolBox: ToolBox(\n        {},\n        {\n          dataZoom: {\n            title: {\n              zoom: '',\n              back: '',\n            },\n            iconStyle: {\n              borderWidth: 0,\n              color: 'transparent',\n              opacity: 0,\n            },\n          },\n        }\n      ),\n      onDataZoom: this.handleDataZoom,\n      onFinished: this.handleChartFinished,\n      onRestore: this.handleZoomRestore,\n      ...props,\n    };\n\n    return children(renderProps);\n  }\n}\n\nexport default ChartZoom;\n","import 'echarts/lib/component/dataZoomInside';\n\nimport type {InsideDataZoomComponentOption} from 'echarts';\n\nconst DEFAULT: InsideDataZoomComponentOption = {\n  type: 'inside',\n  // Mouse wheel can not trigger zoom\n  zoomOnMouseWheel: false,\n  // The translation (by mouse drag or touch drag) is available but zoom is not\n  zoomLock: true,\n  throttle: 50,\n};\n\nexport default function DataZoomInside(\n  props: InsideDataZoomComponentOption | InsideDataZoomComponentOption[]\n): InsideDataZoomComponentOption[] {\n  // `props` can be boolean, if so return default\n  if (!props || !Array.isArray(props)) {\n    const dataZoom = {\n      ...DEFAULT,\n      ...props,\n    };\n    return [dataZoom];\n  }\n\n  return props;\n}\n","import type {ToolboxComponentOption} from 'echarts';\n\nfunction getFeatures({\n  dataZoom,\n  ...features\n}: ToolboxComponentOption['feature'] = {}): ToolboxComponentOption['feature'] {\n  return {\n    ...(dataZoom\n      ? {\n          dataZoom: {\n            yAxisIndex: 'none',\n            title: {\n              zoom: 'zoom',\n              back: 'undo',\n            },\n            ...dataZoom,\n          },\n        }\n      : {}),\n    ...features,\n  };\n}\n\nexport default function ToolBox(\n  options: ToolboxComponentOption,\n  features: ToolboxComponentOption['feature']\n): ToolboxComponentOption {\n  return {\n    right: 0,\n    top: 0,\n    itemSize: 16,\n    // Stack the toolbox under the legend.\n    // so all series names are clickable.\n    z: -1,\n\n    feature: getFeatures(features),\n    ...options,\n  };\n}\n","import {EventsMetaType, MetaType} from 'sentry/utils/discover/eventView';\nimport {TransactionThresholdMetric} from 'sentry/views/performance/transactionSummary/transactionThresholdModal';\n\nimport GenericDiscoverQuery, {\n  DiscoverQueryProps,\n  GenericChildrenProps,\n  useGenericDiscoverQuery,\n} from './genericDiscoverQuery';\n\n/**\n * An individual row in a DiscoverQuery result\n */\nexport type TableDataRow = {\n  [key: string]: React.ReactText;\n  id: string;\n};\n\n/**\n * A DiscoverQuery result including rows and metadata.\n */\nexport type TableData = {\n  data: Array<TableDataRow>;\n  meta?: MetaType;\n};\n\n/**\n * A DiscoverQuery result including rows and metadata from the events endpoint.\n */\nexport type EventsTableData = {\n  data: Array<TableDataRow>;\n  meta?: EventsMetaType;\n};\n\nexport type TableDataWithTitle = TableData & {title: string};\n\nexport type DiscoverQueryPropsWithThresholds = DiscoverQueryProps & {\n  transactionName?: string;\n  transactionThreshold?: number;\n  transactionThresholdMetric?: TransactionThresholdMetric;\n};\n\nexport type DiscoverQueryComponentProps = DiscoverQueryPropsWithThresholds & {\n  children: (props: GenericChildrenProps<TableData>) => React.ReactNode;\n};\n\nfunction shouldRefetchData(\n  prevProps: DiscoverQueryPropsWithThresholds,\n  nextProps: DiscoverQueryPropsWithThresholds\n) {\n  return (\n    prevProps.transactionName !== nextProps.transactionName ||\n    prevProps.transactionThreshold !== nextProps.transactionThreshold ||\n    prevProps.transactionThresholdMetric !== nextProps.transactionThresholdMetric\n  );\n}\n\nfunction DiscoverQuery(props: DiscoverQueryComponentProps) {\n  const afterFetch = (data, _) => {\n    const {fields, ...otherMeta} = data.meta ?? {};\n    return {\n      ...data,\n      meta: {...fields, ...otherMeta},\n    };\n  };\n  return (\n    <GenericDiscoverQuery<TableData, DiscoverQueryPropsWithThresholds>\n      route=\"events\"\n      shouldRefetchData={shouldRefetchData}\n      afterFetch={afterFetch}\n      {...props}\n    />\n  );\n}\n\nexport function useDiscoverQuery(props: Omit<DiscoverQueryComponentProps, 'children'>) {\n  const afterFetch = (data, _) => {\n    const {fields, ...otherMeta} = data.meta ?? {};\n    return {\n      ...data,\n      meta: {...fields, ...otherMeta},\n    };\n  };\n\n  return useGenericDiscoverQuery<TableData, DiscoverQueryPropsWithThresholds>({\n    route: 'events',\n    shouldRefetchData,\n    afterFetch,\n    ...props,\n  });\n}\n\nexport default DiscoverQuery;\n","import 'echarts/lib/chart/scatter';\n\nimport type {ScatterSeriesOption} from 'echarts';\n\nimport theme from 'sentry/utils/theme';\n\nexport default function ScatterSeries(props: ScatterSeriesOption): ScatterSeriesOption {\n  return {\n    symbolSize: theme.charts.symbolSize,\n    ...props,\n    type: 'scatter',\n    emphasis: {\n      ...props.emphasis,\n      scale: true,\n    },\n  };\n}\n","import {useEffect, useRef, useState} from 'react';\nimport {useTheme} from '@emotion/react';\nimport {LineSeriesOption} from 'echarts';\nimport * as echarts from 'echarts/core';\nimport {\n  TooltipFormatterCallback,\n  TopLevelFormatterParams,\n  YAXisOption,\n} from 'echarts/types/dist/shared';\nimport max from 'lodash/max';\nimport min from 'lodash/min';\n\nimport {AreaChart, AreaChartProps} from 'sentry/components/charts/areaChart';\nimport {BarChart} from 'sentry/components/charts/barChart';\nimport BaseChart from 'sentry/components/charts/baseChart';\nimport ChartZoom from 'sentry/components/charts/chartZoom';\nimport {getFormatter} from 'sentry/components/charts/components/tooltip';\nimport {LineChart} from 'sentry/components/charts/lineChart';\nimport LineSeries from 'sentry/components/charts/series/lineSeries';\nimport ScatterSeries from 'sentry/components/charts/series/scatterSeries';\nimport {DateString} from 'sentry/types';\nimport {EChartClickHandler, ReactEchartsRef, Series} from 'sentry/types/echarts';\nimport {\n  axisLabelFormatter,\n  getDurationUnit,\n  tooltipFormatter,\n} from 'sentry/utils/discover/charts';\nimport {aggregateOutputType} from 'sentry/utils/discover/fields';\nimport useRouter from 'sentry/utils/useRouter';\n\nconst STARFISH_CHART_GROUP = 'starfish_chart_group';\n\ntype Props = {\n  data: Series[];\n  end: DateString;\n  loading: boolean;\n  start: DateString;\n  statsPeriod: string | null | undefined;\n  utc: boolean;\n  aggregateOutputFormat?: 'number' | 'percentage' | 'duration';\n  chartColors?: string[];\n  definedAxisTicks?: number;\n  disableXAxis?: boolean;\n  grid?: AreaChartProps['grid'];\n  height?: number;\n  hideYAxisSplitLine?: boolean;\n  isBarChart?: boolean;\n  isLineChart?: boolean;\n  log?: boolean;\n  onClick?: EChartClickHandler;\n  previousData?: Series[];\n  scatterPlot?: Series[];\n  showLegend?: boolean;\n  stacked?: boolean;\n  throughput?: {count: number; interval: string}[];\n};\n\nfunction computeMax(data: Series[]) {\n  const valuesDict = data.map(value => value.data.map(point => point.value));\n\n  return max(valuesDict.map(max)) as number;\n}\n\n// adapted from https://stackoverflow.com/questions/11397239/rounding-up-for-a-graph-maximum\nfunction computeAxisMax(data: Series[]) {\n  // assumes min is 0\n  let maxValue = 0;\n  if (data.length > 2) {\n    for (let i = 0; i < data.length; i++) {\n      maxValue += max(data[i].data.map(point => point.value)) as number;\n    }\n  } else {\n    maxValue = computeMax(data);\n  }\n\n  if (maxValue <= 1) {\n    return 1;\n  }\n\n  const power = Math.log10(maxValue);\n  const magnitude = min([max([10 ** (power - Math.floor(power)), 0]), 10]) as number;\n\n  let scale: number;\n  if (magnitude <= 2.5) {\n    scale = 0.2;\n  } else if (magnitude <= 5) {\n    scale = 0.5;\n  } else if (magnitude <= 7.5) {\n    scale = 1.0;\n  } else {\n    scale = 2.0;\n  }\n\n  const step = 10 ** Math.floor(power) * scale;\n  return Math.round(Math.ceil(maxValue / step) * step);\n}\n\nfunction Chart({\n  data,\n  previousData,\n  statsPeriod,\n  start,\n  end,\n  utc,\n  loading,\n  height,\n  grid,\n  disableXAxis,\n  definedAxisTicks,\n  chartColors,\n  isBarChart,\n  isLineChart,\n  stacked,\n  log,\n  hideYAxisSplitLine,\n  showLegend,\n  scatterPlot,\n  throughput,\n  aggregateOutputFormat,\n  onClick,\n}: Props) {\n  const router = useRouter();\n  const theme = useTheme();\n  const chart = useRef<ReactEchartsRef>(null);\n\n  const echartsInstance = chart.current?.getEchartsInstance();\n  if (echartsInstance && !echartsInstance.group) {\n    echartsInstance.group = STARFISH_CHART_GROUP;\n  }\n\n  if (!data || data.length <= 0) {\n    return null;\n  }\n\n  const colors = chartColors ?? theme.charts.getColorPalette(4);\n\n  const durationOnly =\n    aggregateOutputFormat === 'duration' ||\n    data.every(value => aggregateOutputType(value.seriesName) === 'duration');\n  const percentOnly =\n    aggregateOutputFormat === 'percentage' ||\n    data.every(value => aggregateOutputType(value.seriesName) === 'percentage');\n\n  let dataMax = durationOnly\n    ? computeAxisMax([...data, ...(scatterPlot?.[0]?.data?.length ? scatterPlot : [])])\n    : percentOnly\n    ? computeMax(data)\n    : undefined;\n  // Fix an issue where max == 1 for duration charts would look funky cause we round\n  if (dataMax === 1 && durationOnly) {\n    dataMax += 1;\n  }\n\n  const durationUnit = getDurationUnit(data);\n\n  let transformedThroughput: LineSeriesOption[] | undefined = undefined;\n  const additionalAxis: YAXisOption[] = [];\n\n  if (throughput && throughput.length > 1) {\n    transformedThroughput = [\n      LineSeries({\n        name: 'Throughput',\n        data: throughput.map(({interval, count}) => [interval, count]),\n        yAxisIndex: 1,\n        lineStyle: {type: 'dashed', width: 1, opacity: 0.5},\n        animation: false,\n        animationThreshold: 1,\n        animationDuration: 0,\n      }),\n    ];\n    additionalAxis.push({\n      minInterval: durationUnit,\n      splitNumber: definedAxisTicks,\n      max: dataMax,\n      type: 'value',\n      axisLabel: {\n        color: theme.chartLabel,\n        formatter(value: number) {\n          return axisLabelFormatter(value, 'number', true);\n        },\n      },\n      splitLine: hideYAxisSplitLine ? {show: false} : undefined,\n    });\n  }\n\n  const yAxes = [\n    {\n      minInterval: durationUnit,\n      splitNumber: definedAxisTicks,\n      max: dataMax,\n      type: log ? 'log' : 'value',\n      axisLabel: {\n        color: theme.chartLabel,\n        formatter(value: number) {\n          return axisLabelFormatter(\n            value,\n            aggregateOutputFormat ?? aggregateOutputType(data[0].seriesName),\n            undefined,\n            durationUnit\n          );\n        },\n      },\n      splitLine: hideYAxisSplitLine ? {show: false} : undefined,\n    },\n    ...additionalAxis,\n  ];\n\n  const formatter: TooltipFormatterCallback<TopLevelFormatterParams> = (\n    params,\n    asyncTicket\n  ) => {\n    // Kinda jank. Get hovered dom elements and check if any of them are the chart\n    const hoveredEchartElement = Array.from(document.querySelectorAll(':hover')).find(\n      element => {\n        return element.classList.contains('echarts-for-react');\n      }\n    );\n    if (hoveredEchartElement === chart.current?.ele) {\n      // Return undefined to use default formatter\n      return getFormatter({\n        isGroupedByDate: true,\n        showTimeInTooltip: true,\n        utc,\n      })(params, asyncTicket);\n    }\n    // Return empty string, ie no tooltip\n    return '';\n  };\n\n  const areaChartProps = {\n    seriesOptions: {\n      showSymbol: false,\n    },\n    grid,\n    yAxes,\n    utc,\n    legend: showLegend\n      ? {\n          top: 0,\n          right: 10,\n        }\n      : undefined,\n    isGroupedByDate: true,\n    showTimeInTooltip: true,\n    tooltip: {\n      formatter,\n      trigger: 'axis',\n      axisPointer: {\n        type: 'cross',\n        label: {show: false},\n      },\n      valueFormatter: (value, seriesName) => {\n        return tooltipFormatter(\n          value,\n          aggregateOutputFormat ??\n            aggregateOutputType(data && data.length ? data[0].seriesName : seriesName)\n        );\n      },\n      nameFormatter(value: string) {\n        return value === 'epm()' ? 'tpm()' : value;\n      },\n    },\n  } as Omit<AreaChartProps, 'series'>;\n\n  if (loading) {\n    if (isLineChart) {\n      return <LineChart height={height} series={[]} {...areaChartProps} />;\n    }\n    if (isBarChart) {\n      return <BarChart height={height} series={[]} {...areaChartProps} />;\n    }\n    return <AreaChart height={height} series={[]} {...areaChartProps} />;\n  }\n  const series = data.map((values, _) => ({\n    ...values,\n    yAxisIndex: 0,\n    xAxisIndex: 0,\n  }));\n\n  const xAxis = disableXAxis\n    ? {\n        show: false,\n        axisLabel: {show: true, margin: 0},\n        axisLine: {show: false},\n      }\n    : undefined;\n\n  return (\n    <ChartZoom router={router} period={statsPeriod} start={start} end={end} utc={utc}>\n      {zoomRenderProps => {\n        if (isLineChart) {\n          return (\n            <BaseChart\n              {...zoomRenderProps}\n              ref={chart}\n              height={height}\n              previousPeriod={previousData}\n              additionalSeries={transformedThroughput}\n              xAxis={xAxis}\n              yAxes={areaChartProps.yAxes}\n              tooltip={areaChartProps.tooltip}\n              colors={colors}\n              grid={grid}\n              legend={showLegend ? {top: 0, right: 0} : undefined}\n              onClick={onClick}\n              series={[\n                ...series.map(({seriesName, data: seriesData, ...options}) =>\n                  LineSeries({\n                    ...options,\n                    name: seriesName,\n                    data: seriesData?.map(({value, name}) => [name, value]),\n                    animation: false,\n                    animationThreshold: 1,\n                    animationDuration: 0,\n                  })\n                ),\n                ...(scatterPlot ?? []).map(({seriesName, data: seriesData, ...options}) =>\n                  ScatterSeries({\n                    ...options,\n                    name: seriesName,\n                    data: seriesData?.map(({value, name}) => [name, value]),\n                    animation: false,\n                  })\n                ),\n              ]}\n            />\n          );\n        }\n\n        if (isBarChart) {\n          return (\n            <BarChart\n              height={height}\n              series={series}\n              xAxis={xAxis}\n              additionalSeries={transformedThroughput}\n              yAxes={areaChartProps.yAxes}\n              tooltip={areaChartProps.tooltip}\n              colors={colors}\n              grid={grid}\n              legend={showLegend ? {top: 0, right: 0} : undefined}\n            />\n          );\n        }\n\n        return (\n          <AreaChart\n            forwardedRef={chart}\n            height={height}\n            {...zoomRenderProps}\n            series={series}\n            previousPeriod={previousData}\n            additionalSeries={transformedThroughput}\n            xAxis={xAxis}\n            stacked={stacked}\n            {...areaChartProps}\n          />\n        );\n      }}\n    </ChartZoom>\n  );\n}\n\nexport default Chart;\n\nexport function useSynchronizeCharts(deps: boolean[]) {\n  const [synchronized, setSynchronized] = useState<boolean>(false);\n  useEffect(() => {\n    if (deps.every(dep => dep) && !synchronized) {\n      echarts.connect(STARFISH_CHART_GROUP);\n      setSynchronized(true);\n    }\n  }, [deps, synchronized]);\n}\n","import React from 'react';\nimport styled from '@emotion/styled';\n\nimport {Panel, PanelBody} from 'sentry/components/panels';\nimport {space} from 'sentry/styles/space';\n\ntype Props = {\n  children: React.ReactNode;\n  button?: JSX.Element;\n  title?: string;\n};\n\nexport default function ChartPanel({title, children, button}: Props) {\n  return (\n    <Panel>\n      <PanelBody withPadding>\n        <Header>\n          {title && <ChartLabel>{title}</ChartLabel>}\n          {button}\n        </Header>\n        {children}\n      </PanelBody>\n    </Panel>\n  );\n}\n\nconst ChartLabel = styled('p')`\n  ${p => p.theme.text.cardTitle}\n`;\n\nconst Header = styled('div')`\n  padding: 0 ${space(1)} 0 0;\n  min-height: 36px;\n  width: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n`;\n","import moment from 'moment';\n\nimport {DateTimeObject} from 'sentry/components/charts/utils';\nimport {DateString} from 'sentry/types';\nimport {getPeriodAgo, getUtcDateString, parsePeriodToHours} from 'sentry/utils/dates';\n\nfunction midTimestamp(start: DateString, end: DateString): string {\n  const diff = moment(end).diff(moment(start));\n  const middle = moment(start).add(diff / 2);\n  return getUtcDateString(middle);\n}\n\nexport function getMiddleTimestamp({\n  start,\n  end,\n  statsPeriod,\n}: {\n  end?: string;\n  start?: string;\n  statsPeriod?: string;\n}) {\n  if (statsPeriod) {\n    const rangeStart = getPeriodAgo('hours', parsePeriodToHours(statsPeriod)).toDate();\n    const rangeEnd = new Date();\n    return midTimestamp(rangeStart, rangeEnd);\n  }\n\n  if (!start || !end) {\n    throw new Error('start and end required');\n  }\n\n  return midTimestamp(start, end);\n}\n\nexport const PERIOD_REGEX = /^(\\d+)([h,d])$/;\nexport const DATE_FORMAT = 'YYYY-MM-DD HH:mm:ss';\n\nexport const datetimeToClickhouseFilterTimestamps = (datetime?: DateTimeObject) => {\n  if (!datetime) {\n    return {};\n  }\n  const [_, num, unit] = datetime.period?.match(PERIOD_REGEX) ?? [];\n  const start_timestamp =\n    (datetime.start && moment(datetime.start).format(DATE_FORMAT)) ??\n    (num &&\n      unit &&\n      moment()\n        .subtract(num, unit as 'h' | 'd')\n        .startOf('minute')\n        .format(DATE_FORMAT));\n\n  const end_timestamp = datetime.end && moment(datetime.end).format(DATE_FORMAT);\n  return {start_timestamp, end_timestamp};\n};\n\nexport function getDateFilters(pageFilter) {\n  const [_, num, unit] = pageFilter.selection.datetime.period?.match(PERIOD_REGEX) ?? [];\n  const startTime =\n    num && unit\n      ? moment().subtract(num, unit as 'h' | 'd')\n      : moment(pageFilter.selection.datetime.start);\n  const endTime = moment(pageFilter.selection.datetime.end ?? undefined);\n  return {startTime, endTime};\n}\n","import moment from 'moment';\n\nimport {Series, SeriesDataUnit} from 'sentry/types/echarts';\n\nexport function zeroFillSeries(\n  series: Series,\n  interval: moment.Duration,\n  startTime?: moment.Moment,\n  endTime?: moment.Moment,\n  zerofillValue?: any\n): Series {\n  if (!series?.data?.length) {\n    return series;\n  }\n  if (!zerofillValue) {\n    zerofillValue = 0;\n  }\n\n  const firstDatum = series.data[0];\n  const lastDatum = series.data[series.data.length - 1];\n  const dateFormat = moment(firstDatum.name).creationData().format?.toString();\n\n  if (!dateFormat) {\n    return series;\n  }\n\n  const newData: SeriesDataUnit[] = [];\n\n  const startTimeNearestInterval =\n    startTime && roundDownToNearest12HourInterval(startTime);\n  const endTimeNearestInterval = endTime && roundDownToNearest12HourInterval(endTime);\n\n  const seriesData = [\n    ...(startTimeNearestInterval &&\n    startTimeNearestInterval.diff(moment(firstDatum.name)) < 0\n      ? [{value: zerofillValue, name: startTimeNearestInterval.format(dateFormat)}]\n      : []),\n    ...series.data,\n    ...(endTimeNearestInterval && endTimeNearestInterval.diff(moment(lastDatum.name)) > 0\n      ? [{value: zerofillValue, name: endTimeNearestInterval.format(dateFormat)}]\n      : []),\n  ];\n\n  let currentDatum, nextDatum, lastSeenDate, nextDate, diff;\n  for (let index = 0; index < seriesData.length - 1; index++) {\n    // Push the first datapoint\n    if (index === 0) {\n      newData.push({\n        ...seriesData[index],\n        name: moment(seriesData[index].name).format(dateFormat),\n      });\n    }\n\n    currentDatum = seriesData[index];\n    nextDatum = seriesData[index + 1];\n\n    lastSeenDate = moment(currentDatum.name);\n    nextDate = moment(nextDatum.name);\n\n    diff = moment.duration(nextDate.diff(lastSeenDate));\n\n    while (diff.asMilliseconds() > interval.asMilliseconds()) {\n      // The gap between the two datapoints is more than the intended interval!\n      // We need to fill 0s\n      lastSeenDate.add(interval);\n\n      newData.push({\n        value: zerofillValue,\n        name: moment(lastSeenDate).format(dateFormat),\n      });\n\n      diff = moment.duration(moment(nextDatum.name).diff(lastSeenDate));\n    }\n\n    // Push the next datapoint\n    newData.push({\n      ...nextDatum,\n      name: moment(nextDatum.name).format(dateFormat),\n    });\n  }\n\n  return {\n    ...series,\n    data: newData,\n  };\n}\n\nfunction roundDownToNearest12HourInterval(time: moment.Moment) {\n  const hour = time.hour();\n  const nearestDay = time.clone().startOf('day');\n  if (hour < 12) {\n    return nearestDay;\n  }\n  return nearestDay.add(12, 'hour');\n}\n"],"names":["AreaChart","_ref","series","stacked","colors","props","_jsx","BaseChart","map","_ref2","i","seriesName","data","otherSeriesProps","arguments","length","undefined","LineSeries","AreaSeries","stack","name","_ref3","value","lineStyle","color","opacity","width","areaStyle","animation","animationThreshold","animationDuration","displayName","DEFAULT","realtime","showDetail","left","right","bottom","DataZoomSlider","Array","isArray","getDate","date","moment","format","ChartZoom","Component","constructor","_this","super","this","_defineProperty","currentPeriod","period","start","end","saveHistory","router","onZoom","usePageDate","startFormatted","endFormatted","history","push","zooming","newQuery","location","query","pageStart","getUtcDateString","pageEnd","pageStatsPeriod","qs","pathname","updateDateTime","getUtcToLocalDateObject","skipDesyncUpdate","saveCurrentPeriod","chart","onChartReady","evt","setPeriod","onRestore","model","getModel","startValue","endValue","_payload","batch","previousPeriod","pop","onDataZoom","_props","zoom","_componentsViews","find","c","_features","dataZoom","_isZoomActive","dispatchAction","type","key","dataZoomSelectActive","callIfFunction","onFinished","componentDidUpdate","disabled","render","utc","_utc","_start","_end","children","xAxisIndex","_router","_onZoom","_onRestore","_onChartReady","_onDataZoom","_onFinished","showSlider","chartZoomOptions","isGroupedByDate","handleChartReady","DataZoomInside","showTimeInTooltip","toolBox","ToolBox","title","back","iconStyle","borderWidth","handleDataZoom","handleChartFinished","handleZoomRestore","zoomOnMouseWheel","zoomLock","throttle","getFeatures","features","yAxisIndex","options","top","itemSize","z","feature","shouldRefetchData","prevProps","nextProps","transactionName","transactionThreshold","transactionThresholdMetric","DiscoverQuery","GenericDiscoverQuery","route","afterFetch","_","fields","otherMeta","meta","useDiscoverQuery","useGenericDiscoverQuery","ScatterSeries","symbolSize","theme","emphasis","scale","STARFISH_CHART_GROUP","computeMax","valuesDict","point","max","Chart","previousData","statsPeriod","loading","height","grid","disableXAxis","definedAxisTicks","chartColors","isBarChart","isLineChart","log","hideYAxisSplitLine","showLegend","scatterPlot","throughput","aggregateOutputFormat","onClick","useRouter","useTheme","useRef","echartsInstance","current","getEchartsInstance","group","charts","getColorPalette","durationOnly","every","aggregateOutputType","percentOnly","dataMax","maxValue","power","Math","log10","magnitude","min","floor","step","round","ceil","computeAxisMax","durationUnit","getDurationUnit","transformedThroughput","additionalAxis","interval","count","minInterval","splitNumber","axisLabel","chartLabel","formatter","axisLabelFormatter","splitLine","show","yAxes","areaChartProps","seriesOptions","showSymbol","legend","tooltip","params","asyncTicket","from","document","querySelectorAll","element","classList","contains","ele","getFormatter","trigger","axisPointer","label","valueFormatter","tooltipFormatter","nameFormatter","LineChart","BarChart","values","xAxis","margin","axisLine","zoomRenderProps","ref","additionalSeries","seriesData","_ref4","_ref5","_ref6","forwardedRef","useSynchronizeCharts","deps","synchronized","setSynchronized","useState","useEffect","dep","echarts","ChartPanel","button","Panel","_jsxs","PanelBody","withPadding","Header","ChartLabel","_styled","target","p","text","cardTitle","space","midTimestamp","diff","middle","add","getMiddleTimestamp","getPeriodAgo","parsePeriodToHours","toDate","Date","Error","PERIOD_REGEX","DATE_FORMAT","datetimeToClickhouseFilterTimestamps","datetime","num","unit","match","start_timestamp","subtract","startOf","end_timestamp","getDateFilters","pageFilter","selection","startTime","endTime","zeroFillSeries","zerofillValue","firstDatum","lastDatum","dateFormat","creationData","toString","newData","startTimeNearestInterval","roundDownToNearest12HourInterval","endTimeNearestInterval","currentDatum","nextDatum","lastSeenDate","nextDate","index","asMilliseconds","time","hour","nearestDay","clone"],"sourceRoot":""}