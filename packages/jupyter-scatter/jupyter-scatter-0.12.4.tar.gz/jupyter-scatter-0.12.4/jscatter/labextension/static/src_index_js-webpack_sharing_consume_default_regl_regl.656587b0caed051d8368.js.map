{"version":3,"file":"src_index_js-webpack_sharing_consume_default_regl_regl.656587b0caed051d8368.js","mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,UAAU;AACxB;AACA,UAAU,UAAU;AACpB,UAAU,qBAAqB;AAC/B,UAAU,OAAO;AACjB;;AAEA;AACA;AACA,4CAA4C,sBAAsB;AAClE;AACA;AACA;AACA,eAAe,mCAAmC;AAClD,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gBAAgB;AAClD;AACA;AACA;AACA,KAAK;AACL;AACA,eAAe,YAAY;AAC3B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,sBAAsB;AAClE;AACA;AACA;AACA,eAAe,2BAA2B;AAC1C,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,eAAe,UAAU;AACzB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB;;;;;;;;;;;ACzFnB,gBAAgB,mBAAO,CAAC,oFAAuB;AAC/C,wBAAwB,mBAAO,CAAC,2GAA2C;AAC3E,eAAe,mBAAO,CAAC,yEAAY;AACnC,eAAe,mBAAO,CAAC,gEAAS;AAChC,gBAAgB,mBAAO,CAAC,mEAAU;AAClC,oBAAoB,mBAAO,CAAC,+EAAc;AAC1C,eAAe,mBAAO,CAAC,iCAAU;AACjC,qBAAqB,mBAAO,CAAC,iCAAU;AACvC,oBAAoB,mBAAO,CAAC,uCAAiB;;AAE7C;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;;AAEA;AACA;AACA;AACA;AACA;AACA,qDAAqD,oBAAoB;AACzE;AACA;AACA;AACA;AACA;AACA,wDAAwD,oBAAoB;AAC5E;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,6BAA6B;AACvD,wCAAwC,SAAS,IAAI,SAAS,IAAI,SAAS;;AAE3E;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yCAAyC,kBAAkB;AAC3D;;AAEA;AACA;AACA;;AAEA;AACA,sCAAsC,iBAAiB;AACvD;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL,wCAAwC,SAAS;AACjD,yCAAyC,SAAS;;AAElD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA,iDAAiD,WAAW,IAAI,WAAW;AAC3E;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yCAAyC,uBAAuB;AAChE;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yCAAyC,kBAAkB;AAC3D;AACA;AACA,sCAAsC,iBAAiB;AACvD;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4DAA4D,gBAAgB;AAC5E;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0CAA0C,oBAAoB;AAC9D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB;;AAEtB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,oBAAoB;;AAE7D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,oBAAoB;AACnD,MAAM;AACN,6CAA6C,oBAAoB;AACjE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,UAAU;AACV,UAAU;;AAEV;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;AC5lCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;;AAEA;;AAEA;AACA;AACA;;AAEA,4BAA4B;AAC5B;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,uCAAuC,aAAa;AACpD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;;AAEL;AACA;;AAEA","sources":["webpack://jupyter-scatter/./src/codecs.js","webpack://jupyter-scatter/./src/index.js","webpack://jupyter-scatter/./src/legend.js"],"sourcesContent":["const DTYPES = {\n  uint8: Uint8Array,\n  int8: Int8Array,\n  uint16: Uint16Array,\n  int16: Int16Array,\n  uint32: Uint32Array,\n  int32: Int32Array,\n  float32: Float32Array,\n  float64: Float64Array,\n};\n\n/**\n * @template {number[]} Shape\n * @typedef SerializedArray\n * @prop {DataView} view\n * @prop {keyof typeof DTYPES} dtype\n * @prop {Shape} shape\n */\n\nfunction Numpy2D(dtype) {\n  if (!(dtype in DTYPES)) {\n    throw Error(`Dtype not supported, got ${JSON.stringify(dtype)}.`);\n  }\n  return {\n    /**\n     * @param {SerializedArray<[number, number]>} data\n     * @returns {number[][] | null}\n     */\n    deserialize(data) {\n      if (data == null) return null;\n      // Take full view of data buffer\n      const arr = new DTYPES[dtype](data.view.buffer);\n      // Chunk single TypedArray into nested Array of points\n      const [height, width] = data.shape;\n      // Float32Array(width * height) -> [Array(width), Array(width), ...]\n      const points = Array.from({ length: height }).map((_, i) =>\n        Array.from(arr.subarray(i * width, (i + 1) * width))\n      );\n      return points;\n    },\n    /**\n     * @param {number[][]} data\n     * @returns {SerializedArray<[number, number]>}\n     */\n    serialize(data) {\n      const height = data.length;\n      const width = data[0].length;\n      const arr = new DTYPES[dtype](height * width);\n      for (let i = 0; i < data.length; i++) {\n        arr.set(data[i], i * height);\n      }\n      return {\n        view: new DataView(arr.buffer),\n        dtype: dtype,\n        shape: [height, width],\n      };\n    }\n  }\n}\n\nfunction Numpy1D(dtype) {\n  if (!(dtype in DTYPES)) {\n    throw Error(`Dtype not supported, got ${JSON.stringify(dtype)}.`);\n  }\n  return {\n    /**\n     * @param {SerializedArray<[number]>} data\n     * @returns {number[] | null}\n     */\n    deserialize(data) {\n      if (data == null) return null;\n      // for some reason can't be a typed array\n      return Array.from(new DTYPES[dtype](data.view.buffer));\n    },\n    /**\n     * @param {number[]} data\n     * @returns {SerializedArray<[number]>}\n     */\n    serialize(data) {\n      const arr = new DTYPES[dtype](data);\n      return {\n        view: new DataView(arr.buffer),\n        dtype: dtype,\n        shape: [data.length],\n      };\n    }\n  }\n}\n\nmodule.exports = { Numpy1D, Numpy2D };\n","const widgets = require('@jupyter-widgets/base');\nconst reglScatterplot = require('regl-scatterplot/dist/regl-scatterplot.js');\nconst pubSub = require('pub-sub-es');\nconst d3Axis = require('d3-axis');\nconst d3Scale = require('d3-scale');\nconst d3Selection = require('d3-selection');\nconst codecs = require('./codecs');\nconst createLegend = require('./legend');\nconst packageJson = require('../package.json');\n\nconst createScatterplot = reglScatterplot.default;\nconst createRenderer = reglScatterplot.createRenderer;\n\nclass JupyterScatterModel extends widgets.DOMWidgetModel {\n  defaults() {\n    return Object.assign(\n      {},\n      super.defaults(),\n      {\n        _model_name: 'JupyterScatterModel',\n        _view_name: 'JupyterScatterView',\n        _model_module: packageJson.name,\n        _view_module: packageJson.name,\n        _model_module_version: packageJson.version,\n        _view_module_version: packageJson.version,\n      }\n    );\n  }\n}\n\nJupyterScatterModel.serializers = Object.assign(\n  {},\n  widgets.DOMWidgetModel.serializers,\n  {\n    points: new codecs.Numpy2D('float32'),\n    selection: new codecs.Numpy1D('uint32'),\n    filter: new codecs.Numpy1D('uint32'),\n    view_data: new codecs.Numpy1D('uint8'),\n    zoom_to: new codecs.Numpy1D('uint32'),\n  }\n);\n\nconst AXES_LABEL_SIZE = 16;\nconst AXES_PADDING_X = 40;\nconst AXES_PADDING_X_WITH_LABEL = AXES_PADDING_X + AXES_LABEL_SIZE;\nconst AXES_PADDING_Y = 20;\nconst AXES_PADDING_Y_WITH_LABEL = AXES_PADDING_Y + AXES_LABEL_SIZE;\n\nfunction camelToSnake(string) {\n  return string.replace(/[\\w]([A-Z])/g, function(m) {\n    return m[0] + \"_\" + m[1];\n  }).toLowerCase();\n}\n\nfunction downloadBlob(blob, name) {\n  const link = document.createElement('a');\n  link.href = URL.createObjectURL(blob);\n  link.download = name || 'jscatter.png';\n\n  document.body.appendChild(link);\n\n  link.dispatchEvent(\n    new MouseEvent('click', {\n      bubbles: true,\n      cancelable: true,\n      view: window,\n    })\n  );\n\n  document.body.removeChild(link);\n}\n\nfunction getScale(scaleType) {\n  if (scaleType.startsWith('log')) {\n    return d3Scale.scaleLog().base(scaleType.split('_')[1] || 10);\n  }\n\n  if (scaleType.startsWith('pow')) {\n    return d3Scale.scalePow().exponent(scaleType.split('_')[1] || 2);\n  }\n\n  return d3Scale.scaleLinear();\n}\n\n/**\n * This dictionary maps between the camelCased Python property names and their\n * JavaScript counter parts. In most cases the name is identical but they can be\n * different. E.g., size (Python) vs pointSize (JavaScript)\n */\nconst properties = {\n  backgroundColor: 'backgroundColor',\n  backgroundImage: 'backgroundImage',\n  cameraDistance: 'cameraDistance',\n  cameraRotation: 'cameraRotation',\n  cameraTarget: 'cameraTarget',\n  cameraView: 'cameraView',\n  color: 'pointColor',\n  colorSelected: 'pointColorActive',\n  colorBy: 'colorBy',\n  colorHover: 'pointColorHover',\n  width: 'width',\n  height: 'height',\n  lassoColor: 'lassoColor',\n  lassoInitiator: 'lassoInitiator',\n  lassoOnLongPress: 'lassoOnLongPress',\n  lassoMinDelay: 'lassoMinDelay',\n  lassoMinDist: 'lassoMinDist',\n  mouseMode: 'mouseMode',\n  opacity: 'opacity',\n  opacityBy: 'opacityBy',\n  opacityUnselected: 'opacityInactiveScale',\n  otherOptions: 'otherOptions',\n  points: 'points',\n  reticle: 'showReticle',\n  reticleColor: 'reticleColor',\n  selection: 'selectedPoints',\n  filter: 'filteredPoints',\n  size: 'pointSize',\n  sizeBy: 'sizeBy',\n  connect: 'showPointConnections',\n  connectionColor: 'pointConnectionColor',\n  connectionColorSelected: 'pointConnectionColorActive',\n  connectionColorHover: 'pointConnectionColorHover',\n  connectionColorBy: 'pointConnectionColorBy',\n  connectionOpacity: 'pointConnectionOpacity',\n  connectionOpacityBy: 'pointConnectionOpacityBy',\n  connectionSize: 'pointConnectionSize',\n  connectionSizeBy: 'pointConnectionSizeBy',\n  viewDownload: 'viewDownload',\n  viewReset: 'viewReset',\n  hovering: 'hovering',\n  axes: 'axes',\n  axesColor: 'axesColor',\n  axesGrid: 'axesGrid',\n  axesLabels: 'axesLabels',\n  legend: 'legend',\n  legendSize: 'legendSize',\n  legendColor: 'legendColor',\n  legendPosition: 'legendPosition',\n  legendEncoding: 'legendEncoding',\n  xScale: 'xScale',\n  yScale: 'yScale',\n  zoomTo: 'zoomTo',\n  zoomAnimation: 'zoomAnimation',\n  zoomPadding: 'zoomPadding',\n  zoomOnSelection: 'zoomOnSelection',\n  zoomOnFilter: 'zoomOnFilter',\n};\n\nconst reglScatterplotProperty = new Set([\n  'backgroundColor',\n  'backgroundImage',\n  'cameraDistance',\n  'cameraRotation',\n  'cameraTarget',\n  'cameraView',\n  'pointColor',\n  'pointColorActive',\n  'colorBy',\n  'pointColorHover',\n  'width',\n  'height',\n  'lassoColor',\n  'lassoInitiator',\n  'lassoOnLongPress',\n  'lassoMinDelay',\n  'lassoMinDist',\n  'mouseMode',\n  'opacity',\n  'opacityBy',\n  'opacityInactiveScale',\n  'points',\n  'showReticle',\n  'reticleColor',\n  'selectedPoints',\n  'filteredPoints',\n  'pointSize',\n  'sizeBy',\n  'showPointConnections',\n  'pointConnectionColor',\n  'pointConnectionColorActive',\n  'pointConnectionColorHover',\n  'pointConnectionColorBy',\n  'pointConnectionOpacity',\n  'pointConnectionOpacityBy',\n  'pointConnectionSize',\n  'pointConnectionSizeBy',\n]);\n\n// Custom View. Renders the widget model.\nclass JupyterScatterView extends widgets.DOMWidgetView {\n  render() {\n    const self = this;\n\n    if (!window.jupyterScatter) {\n      window.jupyterScatter = {\n        renderer: createRenderer(),\n        versionLog: false,\n      }\n    }\n\n    Object.keys(properties).forEach(function(propertyName) {\n      self[propertyName] = self.model.get(camelToSnake(propertyName));\n    });\n\n    this.width = !Number.isNaN(+this.model.get('width')) && +this.model.get('width') > 0\n      ? +this.model.get('width')\n      : 'auto';\n\n    // Create a random 6-letter string\n    // From https://gist.github.com/6174/6062387\n    this.randomStr = (\n      Math.random().toString(36).substring(2, 5) +\n      Math.random().toString(36).substring(2, 5)\n    );\n    this.model.set('dom_element_id', this.randomStr);\n\n    this.container = document.createElement('div');\n    this.container.setAttribute('id', this.randomStr);\n    this.container.style.position = 'relative'\n    this.container.style.width = this.width === 'auto'\n      ? '100%'\n      : this.width + 'px';\n    this.container.style.height = this.model.get('height') + 'px';\n    this.el.appendChild(this.container);\n\n    this.canvasWrapper = document.createElement('div');\n    this.canvasWrapper.style.position = 'absolute';\n    this.canvasWrapper.style.top = '0';\n    this.canvasWrapper.style.left = '0';\n    this.canvasWrapper.style.right = '0';\n    this.canvasWrapper.style.bottom = '0';\n    this.container.appendChild(this.canvasWrapper);\n\n    this.canvas = document.createElement('canvas');\n    this.canvas.style.width = '100%';\n    this.canvas.style.height = '100%';\n    this.canvasWrapper.appendChild(this.canvas);\n\n    window.requestAnimationFrame(function init() {\n      const initialOptions = {\n        renderer: window.jupyterScatter.renderer,\n        canvas: self.canvas,\n      }\n\n      if (self.width !== 'auto') initialOptions.width = self.width;\n\n      Object.entries(properties).forEach(function(property) {\n        const pyName = property[0];\n        const jsName = property[1];\n        if (self[pyName] !== null && reglScatterplotProperty.has(jsName))\n          initialOptions[jsName] = self[pyName];\n      });\n\n      self.scatterplot = createScatterplot(initialOptions);\n\n      if (!window.jupyterScatter.versionLog) {\n        // eslint-disable-next-line\n        console.log(\n          'jupyter-scatter v' + packageJson.version +\n          ' with regl-scatterplot v' + self.scatterplot.get('version')\n        );\n        window.jupyterScatter.versionLog = true;\n      }\n\n      self.container.api = self.scatterplot;\n\n      if (self.model.get('axes')) self.createAxes();\n      if (self.model.get('axes_grid')) self.createAxesGrid();\n      if (self.model.get('legend')) self.showLegend();\n\n      // Listen to events from the JavaScript world\n      self.pointoverHandlerBound = self.pointoverHandler.bind(self);\n      self.pointoutHandlerBound = self.pointoutHandler.bind(self);\n      self.selectHandlerBound = self.selectHandler.bind(self);\n      self.deselectHandlerBound = self.deselectHandler.bind(self);\n      self.filterEventHandlerBound = self.filterEventHandler.bind(self);\n      self.externalViewChangeHandlerBound = self.externalViewChangeHandler.bind(self);\n      self.viewChangeHandlerBound = self.viewChangeHandler.bind(self);\n      self.resizeHandlerBound = self.resizeHandler.bind(self);\n\n      self.scatterplot.subscribe('pointover', self.pointoverHandlerBound);\n      self.scatterplot.subscribe('pointout', self.pointoutHandlerBound);\n      self.scatterplot.subscribe('select', self.selectHandlerBound);\n      self.scatterplot.subscribe('deselect', self.deselectHandlerBound);\n      self.scatterplot.subscribe('filter', self.filterEventHandlerBound);\n      self.scatterplot.subscribe('view', self.viewChangeHandlerBound);\n\n      pubSub.globalPubSub.subscribe(\n        'jscatter::view', self.externalViewChangeHandlerBound\n      );\n\n      if ('ResizeObserver' in window) {\n        self.canvasObserver = new ResizeObserver(self.resizeHandlerBound);\n        self.canvasObserver.observe(self.canvas);\n      } else {\n        window.addEventListener('resize', self.resizeHandlerBound);\n        window.addEventListener('orientationchange', self.resizeHandlerBound);\n      }\n\n      // Listen to messages from the Python world\n      Object.keys(properties).forEach(function(propertyName) {\n        if (self[propertyName + 'Handler']) {\n          self.model.on(\n            'change:' + camelToSnake(propertyName),\n            self.withModelChangeHandler(\n              propertyName,\n              self[propertyName + 'Handler'].bind(self)\n            ),\n            self\n          );\n        }\n      });\n\n      self.colorCanvas();\n\n      if (self.points.length) {\n        self.scatterplot\n          .draw(self.points)\n          .then(function onInitialDraw() {\n            if (self.filter.length) {\n              self.scatterplot.filter(self.filter, { preventEvent: true });\n              if (self.model.get('zoom_on_filter')) {\n                self.zoomToHandler(self.filter);\n              }\n            }\n            if (self.selection.length) {\n              self.scatterplot.select(self.selection, { preventEvent: true });\n              if (self.model.get('zoom_on_selection')) {\n                self.zoomToHandler(self.selection);\n              }\n            }\n          });\n      }\n    });\n\n    this.model.save_changes();\n  }\n\n  getOuterDimensions() {\n    let xPadding = 0;\n    let yPadding = 0;\n\n    if (this.model.get('axes')) {\n      const labels = this.model.get('axes_labels');\n      xPadding = labels ? AXES_PADDING_X_WITH_LABEL : AXES_PADDING_X;\n      yPadding = labels ? AXES_PADDING_Y_WITH_LABEL : AXES_PADDING_Y;\n    }\n\n    const outerWidth = this.model.get('width') === 'auto'\n      ? this.container.getBoundingClientRect().width\n      : this.model.get('width') + xPadding;\n\n    const outerHeight = this.model.get('height') + yPadding;\n\n    return [outerWidth, outerHeight]\n  }\n\n  createAxes() {\n    this.axesSvg = d3Selection.select(this.container).select('svg').node()\n      ? d3Selection.select(this.container).select('svg')\n      : d3Selection.select(this.container).append('svg');\n    this.axesSvg.style('top', 0);\n    this.axesSvg.style('left', 0);\n    this.axesSvg.style('width', '100%');\n    this.axesSvg.style('height', '100%');\n    this.axesSvg.style('pointer-events', 'none');\n    this.axesSvg.style('user-select', 'none');\n    const color = this.model.get('axes_color')\n      .map(function (c) { return Math.round(c * 255); });\n    this.axesSvg.style('color', `rgba(${color[0]}, ${color[1]}, ${color[2]}, 1)`);\n\n    const [width, height] = this.getOuterDimensions();\n\n    const currentXScaleRegl = this.scatterplot.get('xScale');\n    const currentYScaleRegl = this.scatterplot.get('yScale');\n\n    const labels = this.model.get('axes_labels');\n    const xPadding = labels ? AXES_PADDING_X_WITH_LABEL : AXES_PADDING_X;\n    const yPadding = labels ? AXES_PADDING_Y_WITH_LABEL : AXES_PADDING_Y;\n\n    // Regl-Scatterplot's gl-space is always linear, hence we have to pass a\n    // linear scale to regl-scatterplot.\n    // In the future we might integrate this into regl-scatterplot directly\n    this.xScaleRegl = d3Scale.scaleLinear()\n      .domain(this.model.get('x_domain'))\n      .range([0, width - xPadding]);\n    // This scale is used for the D3 axis\n    this.xScaleAxis = getScale(this.model.get('x_scale'))\n      .domain(this.model.get('x_domain'))\n      .range([0, width - xPadding]);\n    // This scale converts between the linear, log, or power normalized data\n    // scale and the axis\n    this.xScaleRegl2Axis = getScale(this.model.get('x_scale'))\n      .domain(this.model.get('x_domain'))\n      .range(this.model.get('x_domain'));\n\n    this.yScaleRegl = d3Scale.scaleLinear()\n      .domain(this.model.get('y_domain'))\n      .range([height - yPadding, 0]);\n    this.yScaleAxis = getScale(this.model.get('y_scale'))\n      .domain(this.model.get('y_domain'))\n      .range([height - yPadding, 0]);\n    this.yScaleRegl2Axis = getScale(this.model.get('y_scale'))\n      .domain(this.model.get('y_domain'))\n      .range(this.model.get('y_domain'));\n\n    if (currentXScaleRegl) {\n      this.xScaleAxis.domain(\n        currentXScaleRegl.domain().map(this.xScaleRegl2Axis.invert)\n      );\n    }\n\n    if (currentYScaleRegl) {\n      this.yScaleAxis.domain(\n        currentYScaleRegl.domain().map(this.yScaleRegl2Axis.invert)\n      );\n    }\n\n    this.xAxis = d3Axis.axisBottom(this.xScaleAxis);\n    this.yAxis = d3Axis.axisRight(this.yScaleAxis);\n\n    this.xAxisContainer = this.axesSvg.select('.x-axis').node()\n      ? this.axesSvg.select('.x-axis')\n      : this.axesSvg.append('g').attr('class', 'x-axis');\n\n    this.xAxisContainer\n      .attr('transform', `translate(0, ${height - yPadding})`)\n      .call(this.xAxis);\n\n    this.yAxisContainer = this.axesSvg.select('.y-axis').node()\n      ? this.axesSvg.select('.y-axis')\n      : this.axesSvg.append('g').attr('class', 'y-axis');\n\n    this.yAxisContainer\n      .attr('transform', `translate(${width - xPadding}, 0)`)\n      .call(this.yAxis);\n\n    this.axesSvg.selectAll('.domain').attr('opacity', 0);\n\n    if (labels) {\n      this.xAxisLabel = this.axesSvg.select('.x-axis-label').node()\n        ? this.axesSvg.select('.x-axis-label')\n        : this.axesSvg.append('text').attr('class', 'x-axis-label');\n\n      this.xAxisLabel\n        .text(labels[0])\n        .attr('text-anchor', 'middle')\n        .attr('font-size', '12px')\n        .attr('font-weight', 'bold')\n        .attr('x', (width - xPadding) / 2)\n        .attr('y', height);\n\n      this.yAxisLabel = this.axesSvg.select('.y-axis-label').node()\n        ? this.axesSvg.select('.y-axis-label')\n        : this.axesSvg.append('text').attr('class', 'y-axis-label');\n\n      this.yAxisLabel\n        .text(labels[1])\n        .attr('text-anchor', 'middle')\n        .attr('dominant-baseline', 'hanging')\n        .attr('x', (height - yPadding) / 2)\n        .attr('y', -width)\n        .attr('font-size', '12px')\n        .attr('font-weight', 'bold')\n        .attr('transform', `rotate(90)`);\n    }\n\n    this.updateContainerDimensions();\n\n    this.scatterplot.set({\n      xScale: this.xScaleRegl,\n      yScale: this.yScaleRegl,\n    });\n\n    this.canvasWrapper.style.right = `${xPadding}px`;\n    this.canvasWrapper.style.bottom = `${yPadding}px`;\n\n    if (this.model.get('axes_grid')) this.createAxesGrid();\n\n    this.updateLegendWrapperPosition();\n  }\n\n  removeAxes() {\n    this.axesSvg.node().remove();\n    this.axesSvg = undefined;\n    this.xAxis = undefined;\n    this.yAxis = undefined;\n    this.xAxisContainer = undefined;\n    this.yAxisContainer = undefined;\n    this.xAxisContainer = undefined;\n    this.xAxisLabel = undefined;\n    this.yAxisLabel = undefined;\n\n    this.canvasWrapper.style.top = '0';\n    this.canvasWrapper.style.left = '0';\n    this.canvasWrapper.style.right = '0';\n    this.canvasWrapper.style.bottom = '0';\n\n    this.updateContainerDimensions();\n\n    this.scatterplot.set({\n      xScale: undefined,\n      yScale: undefined,\n    });\n  }\n\n  createAxesGrid() {\n    const { width, height } = this.canvasWrapper.getBoundingClientRect();\n    if (this.xAxis) {\n      this.xAxis.tickSizeInner(-height);\n      this.xAxisContainer.call(this.xAxis);\n    }\n    if (this.yAxis) {\n      this.yAxis.tickSizeInner(-width);\n      this.yAxisContainer.call(this.yAxis);\n    }\n    if (this.axesSvg) {\n      this.axesSvg.selectAll('line')\n        .attr('stroke-opacity', 0.2)\n        .attr('stroke-dasharray', 2);\n    }\n  }\n\n  removeAxesGrid() {\n    if (this.xAxis) {\n      this.xAxis.tickSizeInner(6);\n      this.xAxisContainer.call(this.xAxis);\n    }\n    if (this.yAxis) {\n      this.yAxis.tickSizeInner(6);\n      this.yAxisContainer.call(this.yAxis);\n    }\n    if (this.axesSvg) {\n      this.axesSvg.selectAll('line')\n        .attr('stroke-opacity', null)\n        .attr('stroke-dasharray', null);\n    }\n  }\n\n  showLegend() {\n    this.hideLegend();\n\n    this.legendWrapper = document.createElement('div');\n    this.legendWrapper.className = 'legend-wrapper';\n    this.legendWrapper.style.position = 'absolute';\n    this.legendWrapper.style.pointerEvents = 'none';\n    this.updateLegendWrapperPosition();\n\n    this.legend = createLegend(\n      this.model.get('legend_encoding'),\n      this.model.get('legend_color'),\n      this.model.get('background_color'),\n      this.model.get('legend_size')\n    );\n    this.updateLegendPosition();\n\n    this.legendWrapper.appendChild(this.legend);\n    this.container.appendChild(this.legendWrapper);\n  }\n\n  hideLegend() {\n    if (!this.legendWrapper) return;\n    this.container.removeChild(this.legendWrapper);\n    this.legendWrapper = undefined;\n    this.legend = undefined;\n  }\n\n  updateLegendWrapperPosition() {\n    if (!this.legendWrapper) return;\n\n    const labels = this.model.get('axes_labels');\n    const xPadding = labels ? AXES_PADDING_X_WITH_LABEL : AXES_PADDING_X;\n    const yPadding = labels ? AXES_PADDING_Y_WITH_LABEL : AXES_PADDING_Y;\n\n    this.legendWrapper.style.top = 0;\n    this.legendWrapper.style.bottom = yPadding + 'px';\n    this.legendWrapper.style.left = 0;\n    this.legendWrapper.style.right = xPadding + 'px';\n  }\n\n  updateLegendPosition() {\n    if (!this.legend) return;\n\n    this.legend.style.position = 'absolute';\n    this.legend.style.top = null;\n    this.legend.style.bottom = null;\n    this.legend.style.left = null;\n    this.legend.style.right = null;\n    this.legend.style.transform = null;\n\n    const position = this.model.get('legend_position');\n    let translateX = 0;\n    let translateY = 0;\n\n    if (position.indexOf('top') >= 0) {\n      this.legend.style.top = 0;\n    } else if (position.indexOf('bottom') >= 0) {\n      this.legend.style.bottom = 0;\n    } else {\n      this.legend.style.top = '50%';\n      translateY = '-50%';\n    }\n\n    if (position.indexOf('left') >= 0) {\n      this.legend.style.left = 0;\n    } else if (position.indexOf('right') >= 0) {\n      this.legend.style.right = 0;\n    } else {\n      this.legend.style.left = '50%';\n      translateX = '-50%';\n    }\n\n    if (translateX || translateY) {\n      this.legend.style.transform = `translate(${translateX}, ${translateY})`;\n    }\n  }\n\n  updateContainerDimensions() {\n    const width = this.model.get('width');\n    const height = this.model.get('height');\n\n    let xPadding = 0;\n    let yPadding = 0;\n\n    if (this.model.get('axes')) {\n      const labels = this.model.get('axes_labels');\n      xPadding = labels ? AXES_PADDING_X_WITH_LABEL : AXES_PADDING_X;\n      yPadding = labels ? AXES_PADDING_Y_WITH_LABEL : AXES_PADDING_Y;\n    }\n\n    this.container.style.width = width === 'auto'\n      ? '100%'\n      : (width + xPadding) + 'px';\n    this.container.style.height = (height + yPadding) + 'px';\n\n    window.requestAnimationFrame(() => { this.resizeHandler(); });\n  }\n\n  resizeHandler() {\n    if (!this.model.get('axes')) return;\n\n    const [width, height] = this.getOuterDimensions();\n\n    const labels = this.model.get('axes_labels');\n    const xPadding = labels ? AXES_PADDING_X_WITH_LABEL : AXES_PADDING_X;\n    const yPadding = labels ? AXES_PADDING_Y_WITH_LABEL : AXES_PADDING_Y;\n\n    this.xScaleAxis.range([0, width - xPadding]);\n    this.yScaleAxis.range([height - yPadding, 0]);\n    this.xAxis.scale(this.xScaleAxis);\n    this.yAxis.scale(this.yScaleAxis);\n\n    this.xAxisContainer\n      .attr('transform', `translate(0, ${height - yPadding})`)\n      .call(this.xAxis);\n    this.yAxisContainer\n      .attr('transform', `translate(${width - xPadding}, 0)`)\n      .call(this.yAxis);\n\n    this.updateLegendWrapperPosition();\n\n    this.withPropertyChangeHandler('width', this.model.get('width') || 'auto');\n    this.withPropertyChangeHandler('height', this.model.get('height'));\n\n    // Render grid\n    if (this.model.get('axes_grid')) {\n      this.xAxis.tickSizeInner(-(height - yPadding));\n      this.yAxis.tickSizeInner(-(width - xPadding));\n    }\n\n    if (labels) {\n      this.xAxisLabel.attr('x', (width - xPadding) / 2).attr('y', height);\n      this.yAxisLabel.attr('x', (height - yPadding) / 2).attr('y', -width);\n    }\n  }\n\n  destroy() {\n    if (this.canvasObserver) {\n      this.canvasObserver.disconnect();\n    } else {\n      window.removeEventListener('resize', this.resizeHandlerBound);\n      window.removeEventListener('orientationchange', this.resizeHandlerBound);\n    }\n    pubSub.globalPubSub.unsubscribe(\n      'jscatter::view',\n      this.externalViewChangeHandlerBound\n    );\n    this.scatterplot.unsubscribe('pointover', this.pointoverHandlerBound);\n    this.scatterplot.unsubscribe('pointout', this.pointoutHandlerBound);\n    this.scatterplot.unsubscribe('select', this.selectHandlerBound);\n    this.scatterplot.unsubscribe('deselect', this.deselectHandlerBound);\n    this.scatterplot.unsubscribe('filter', this.filterEventHandlerBound);\n    this.scatterplot.unsubscribe('view', this.viewChangeHandlerBound);\n    this.scatterplot.destroy();\n  }\n\n  remove() {\n    this.destroy();\n  }\n\n  // Helper\n  colorCanvas() {\n    if (Array.isArray(this.backgroundColor)) {\n      this.container.style.backgroundColor = 'rgb(' +\n        this.backgroundColor.slice(0, 3).map(function (x) { return x * 255 }).join(',') +\n        ')';\n    } else {\n      this.container.style.backgroundColor = this.backgroundColor;\n    }\n  }\n\n  // Event handlers for JS-triggered events\n  pointoverHandler(pointIndex) {\n    this.hoveringChangedByJs = true;\n    this.model.set('hovering', pointIndex);\n    this.model.save_changes();\n  }\n\n  pointoutHandler() {\n    this.hoveringChangedByJs = true;\n    this.model.set('hovering', null);\n    this.model.save_changes();\n  }\n\n  selectHandler(event) {\n    this.selectionChangedByJs = true;\n    if (this.model.get('zoom_on_selection')) this.zoomToHandler(event.points);\n    this.model.set('selection', [...event.points]);\n    this.model.save_changes();\n  }\n\n  deselectHandler() {\n    this.selectionChangedByJs = true;\n    if (this.model.get('zoom_on_selection')) this.zoomToHandler();\n    this.model.set('selection', []);\n    this.model.save_changes();\n  }\n\n  filterEventHandler(event) {\n    this.filterChangedByJs = true;\n    if (this.model.get('zoom_on_filter')) this.zoomToHandler(event.points);\n    this.model.set('filter', [...event.points]);\n    this.model.save_changes();\n  }\n\n  externalViewChangeHandler(event) {\n    if (\n      event.uuid === this.model.get('view_sync') &&\n      event.src !== this.randomStr\n    ) {\n      this.scatterplot.view(event.view, { preventEvent: true });\n    }\n  }\n\n  viewChangeHandler(event) {\n    const viewSync = this.model.get('view_sync');\n    if (viewSync) {\n      pubSub.globalPubSub.publish(\n        'jscatter::view',\n        {\n          src: this.randomStr,\n          uuid: viewSync,\n          view: event.view,\n        }\n      );\n    }\n    if (this.model.get('axes')) {\n      this.xScaleAxis.domain(event.xScale.domain().map(this.xScaleRegl2Axis.invert));\n      this.yScaleAxis.domain(event.yScale.domain().map(this.yScaleRegl2Axis.invert));\n\n      this.xAxisContainer.call(this.xAxis.scale(this.xScaleAxis));\n      this.yAxisContainer.call(this.yAxis.scale(this.yScaleAxis));\n\n      if (this.model.get('axes_grid')) {\n        this.axesSvg.selectAll('line')\n          .attr('stroke-opacity', 0.2)\n          .attr('stroke-dasharray', 2);\n      }\n    }\n  }\n\n  xScaleHandler() {\n    this.createAxes();\n  }\n\n  yScaleHandler() {\n    this.createAxes();\n  }\n\n  // Event handlers for Python-triggered events\n  pointsHandler(newPoints) {\n    if (newPoints.length === this.scatterplot.get('points').length) {\n      // We assume point correspondence\n      this.scatterplot.draw(newPoints, {\n        transition: true,\n        transitionDuration: 3000,\n        transitionEasing: 'quadInOut',\n      });\n    } else {\n      this.scatterplot.deselect();\n      this.scatterplot.unfilter();\n      this.scatterplot.draw(newPoints);\n    }\n  }\n\n  selectionHandler(pointIdxs) {\n    // Avoid calling `this.scatterplot.select()` twice when the selection was\n    // triggered by the JavaScript (i.e., the user interactively selected points)\n    if (this.selectionChangedByJs) {\n      this.selectionChangedByJs = undefined;\n      return;\n    }\n\n    const selection = pointIdxs?.length > 0\n      ? pointIdxs\n      : undefined;\n\n    const options = { preventEvent: true };\n\n    if (selection) this.scatterplot.select(selection, options);\n    else this.scatterplot.deselect(options);\n\n    if (this.model.get('zoom_on_selection')) this.zoomToHandler(selection);\n  }\n\n  filterHandler(pointIdxs) {\n    // Avoid calling `this.scatterplot.select()` twice when the selection was\n    // triggered by the JavaScript (i.e., the user interactively selected points)\n    if (this.filterChangedByJs) {\n      this.filterChangedByJs = undefined;\n      return;\n    }\n\n    this.scatterplot.filter(pointIdxs, { preventEvent: true });\n\n    if (this.model.get('zoom_on_filter')) this.zoomToHandler(pointIdxs);\n  }\n\n  hoveringHandler(newHovering) {\n    // Avoid calling `this.scatterplot.hover()` twice when the hovering was\n    // triggered by the JavaScript (i.e., the user interactively selected points)\n    if (this.hoveringChangedByJs) {\n      this.hoveringChangedByJs = undefined;\n      return;\n    }\n\n    if (Number.isNaN(+newHovering)) {\n      this.scatterplot.hover({ preventEvent: true });\n    } else {\n      this.scatterplot.hover(+newHovering, { preventEvent: true });\n    }\n  }\n\n  widthHandler() {\n    this.updateContainerDimensions();\n  }\n\n  heightHandler() {\n    this.updateContainerDimensions();\n  }\n\n  backgroundColorHandler(newValue) {\n    this.withPropertyChangeHandler('backgroundColor', newValue);\n    this.colorCanvas();\n  }\n\n  backgroundImageHandler(newValue) {\n    this.withPropertyChangeHandler('backgroundImage', newValue);\n  }\n\n  lassoColorHandler(newValue) {\n    this.withPropertyChangeHandler('lassoColor', newValue);\n  }\n\n  lassoMinDelayHandler(newValue) {\n    this.withPropertyChangeHandler('lassoMinDelay', newValue);\n  }\n\n  lassoMinDistHandler(newValue) {\n    this.withPropertyChangeHandler('lassoMinDist', newValue);\n  }\n\n  colorHandler(newValue) {\n    this.withPropertyChangeHandler('pointColor', newValue);\n  }\n\n  colorSelectedHandler(newValue) {\n    this.withPropertyChangeHandler('pointColorActive', newValue);\n  }\n\n  colorHoverHandler(newValue) {\n    this.withPropertyChangeHandler('pointColorHover', newValue);\n  }\n\n  colorByHandler(newValue) {\n    this.withPropertyChangeHandler('colorBy', newValue);\n  }\n\n  opacityHandler(newValue) {\n    this.withPropertyChangeHandler('opacity', newValue);\n  }\n\n  opacityUnselectedHandler(newValue) {\n    this.withPropertyChangeHandler('opacityInactiveScale', newValue);\n  }\n\n  opacityByHandler(newValue) {\n    this.withPropertyChangeHandler('opacityBy', newValue);\n  }\n\n  sizeHandler(newValue) {\n    this.withPropertyChangeHandler('pointSize', newValue);\n  }\n\n  sizeByHandler(newValue) {\n    this.withPropertyChangeHandler('sizeBy', newValue);\n  }\n\n  connectHandler(newValue) {\n    this.withPropertyChangeHandler('showPointConnections', Boolean(newValue));\n  }\n\n  connectionColorHandler(newValue) {\n    this.withPropertyChangeHandler('pointConnectionColor', newValue);\n  }\n\n  connectionColorSelectedHandler(newValue) {\n    this.withPropertyChangeHandler('pointConnectionColorActive', newValue);\n  }\n\n  connectionColorHoverHandler(newValue) {\n    this.withPropertyChangeHandler('pointConnectionColorHover', newValue);\n  }\n\n  connectionColorByHandler(newValue) {\n    this.withPropertyChangeHandler('pointConnectionColorBy', newValue);\n  }\n\n  connectionOpacityHandler(newValue) {\n    this.withPropertyChangeHandler('pointConnectionOpacity', newValue);\n  }\n\n  connectionOpacityByHandler(newValue) {\n    this.withPropertyChangeHandler('pointConnectionOpacityBy', newValue);\n  }\n\n  connectionSizeHandler(newValue) {\n    this.withPropertyChangeHandler('pointConnectionSize', newValue);\n  }\n\n  connectionSizeByHandler(newValue) {\n    this.withPropertyChangeHandler('pointConnectionSizeBy', newValue);\n  }\n\n  reticleHandler(newValue) {\n    this.withPropertyChangeHandler('showReticle', newValue);\n  }\n\n  reticleColorHandler(newValue) {\n    this.withPropertyChangeHandler('reticleColor', newValue);\n  }\n\n  cameraTargetHandler(newValue) {\n    this.withPropertyChangeHandler('cameraTarget', newValue);\n  }\n\n  cameraDistanceHandler(newValue) {\n    this.withPropertyChangeHandler('cameraDistance', newValue);\n  }\n\n  cameraRotationHandler(newValue) {\n    this.withPropertyChangeHandler('cameraRotation', newValue);\n  }\n\n  cameraViewHandler(newValue) {\n    this.withPropertyChangeHandler('cameraView', newValue);\n  }\n\n  lassoInitiatorHandler(newValue) {\n    this.withPropertyChangeHandler('lassoInitiator', newValue);\n  }\n\n  lassoOnLongPressHandler(newValue) {\n    this.withPropertyChangeHandler('lassoOnLongPress', newValue);\n  }\n\n  mouseModeHandler(newValue) {\n    this.withPropertyChangeHandler('mouseMode', newValue);\n  }\n\n  axesHandler(newValue) {\n    if (newValue) this.createAxes();\n    else this.removeAxes();\n  }\n\n  axesColorHandler() {\n    this.createAxes();\n  }\n\n  axesGridHandler(newValue) {\n    if (newValue) this.createAxesGrid();\n    else this.removeAxesGrid();\n  }\n\n  axesLabelsHandler(newValue) {\n    if (!newValue) this.removeAxes();\n    this.createAxes();\n  }\n\n  legendHandler(newValue) {\n    if (newValue) this.showLegend();\n    else this.hideLegend();\n  }\n\n  legendColorHandler() {\n    this.hideLegend();\n    this.showLegend();\n  }\n\n  legendSizeHandler() {\n    this.hideLegend();\n    this.showLegend();\n  }\n\n  legendPositionHandler() {\n    this.updateLegendPosition();\n  }\n\n  legendEncodingHandler() {\n    if (!this.model.get('legend')) return;\n    this.showLegend();\n  }\n\n  zoomToHandler(points) {\n    const animation = this.model.get('zoom_animation');\n    const padding = this.model.get('zoom_padding');\n\n    const transition = animation > 0;\n    const transitionDuration = animation;\n\n    const options = transition\n      ? { padding, transition, transitionDuration }\n      : { padding };\n\n    if (points && points.length) {\n      this.scatterplot.zoomToPoints(points, options);\n    } else {\n      this.scatterplot.zoomToOrigin(options);\n    }\n  }\n\n  otherOptionsHandler(newOptions) {\n    this.scatterplot.set(newOptions);\n  }\n\n  viewDownloadHandler(target) {\n    if (!target) return;\n\n    if (target === 'property') {\n      const image = this.scatterplot.export();\n      this.model.set('view_data', image.data);\n      this.model.set('view_shape', [image.width, image.height]);\n      this.model.set('view_download', null);\n      this.model.save_changes();\n      return;\n    }\n\n    this.scatterplot.get('canvas').toBlob((blob) => {\n      downloadBlob(blob, 'scatter.png');\n      setTimeout(() => {\n        this.model.set('view_download', null);\n        this.model.save_changes();\n      }, 0);\n    });\n  }\n\n  viewResetHandler() {\n    this.scatterplot.reset();\n    setTimeout(() => {\n      this.model.set('view_reset', false);\n      this.model.save_changes();\n    }, 0);\n  }\n\n  withPropertyChangeHandler(property, changedValue) {\n    const p = {};\n    p[property] = changedValue;\n    this.scatterplot.set(p);\n  }\n\n  withModelChangeHandler(property, handler) {\n    const self = this;\n\n    return function modelChangeHandler() {\n      const changes = self.model.changedAttributes();\n      const pyPropertyName = camelToSnake(property);\n\n      if (\n        changes[pyPropertyName] === undefined ||\n        self[property + 'Changed'] === true\n      ) {\n        self[property + 'Changed'] = false;\n        return;\n      };\n\n      self[property] = changes[camelToSnake(property)];\n\n      if (handler) handler(self[property]);\n    }\n  }\n};\n\nmodule.exports = {\n  JupyterScatterModel: JupyterScatterModel,\n  JupyterScatterView: JupyterScatterView\n};\n","const sortOrder = {\n  'color': 0,\n  'opacity': 1,\n  'size': 2,\n  'connection_color': 3,\n  'connection_opacity': 4,\n  'connection_size': 5,\n}\n\nfunction createLabelFormatter(valueRange) {\n  const min = valueRange[0];\n  const max = valueRange[1];\n\n  if (Number.isNaN(Number(min)) || Number.isNaN(Number(max))) {\n    return function (value) { return value };\n  }\n\n  const extent = max - min;\n\n  const i = Math.floor(Math.log10(extent));\n  const k = Math.max(0, i >= 0 ? 2 - i : 1 - i);\n  const l = Math.pow(10, k);\n\n  return function (value) { return (Math.round(value * l) / l).toFixed(k); }\n}\n\nfunction createValue(value) {\n  const element = document.createElement('span');\n  element.className = 'legend-value';\n  element.style.marginLeft = '0.25rem';\n\n  element.textContent = value;\n\n  return element;\n}\n\nfunction createLabel(label) {\n  const element = document.createElement('span');\n  element.className = 'legend-label';\n  element.style.opacity = 0.5;\n\n  element.textContent = label || '';\n\n  return element;\n}\n\nfunction createIcon(\n  visualChannel,\n  encoding,\n  encodingRange,\n  sizePx,\n  fontColor\n) {\n  const element = document.createElement('div');\n  element.className = 'legend-icon';\n  element.style.width = sizePx + 'px';\n  element.style.height = sizePx + 'px';\n  element.style.borderRadius = sizePx + 'px';\n  element.style.backgroundColor = 'rgb(' + fontColor + ','  + fontColor + ',' + fontColor + ')';\n\n  if (visualChannel.includes('color')) {\n    element.style.backgroundColor = Array.isArray(encoding)\n      ? 'rgb(' + encoding.slice(0, 3).map((v) => v * 255).join(', ') + ')'\n      : encoding;\n  } else if (visualChannel.includes('opacity')) {\n    element.style.backgroundColor = 'rgba(' + fontColor + ',' + fontColor + ','  + fontColor + ',' + encoding + ')';\n    if (encoding < 0.2) {\n      element.style.boxShadow = 'inset 0 0 1px rgba(' + fontColor + ',' + fontColor + ','  + fontColor + ', 0.66)';\n    }\n  } else if (visualChannel.includes('size')) {\n    const minValue = Math.min.apply(null, encodingRange);\n    const maxValue = Math.max.apply(null, encodingRange);\n    const extent = maxValue - minValue;\n    const normEncoding = 0.2 + ((encoding - minValue) / extent) * 0.8;\n    element.style.transform = `scale(${normEncoding})`;\n  }\n\n  return element;\n}\n\nfunction createEntry(\n  visualChannel,\n  value,\n  encodedValue,\n  encodingRange,\n  sizePx,\n  fontColor\n) {\n  const element = document.createElement('div');\n  element.className = 'legend-entry';\n  element.style.display = 'flex';\n  element.style.alignItems = 'center';\n\n  element.appendChild(\n    createIcon(visualChannel, encodedValue, encodingRange, sizePx, fontColor)\n  );\n  element.appendChild(createValue(value));\n\n  return element;\n}\n\nfunction createTitle(visualChannel, isRightAligned) {\n  const element = document.createElement('div');\n  element.className = 'legend-title';\n  element.style.textTransform = 'capitalize';\n  element.style.fontWeight = 'bold';\n  if (isRightAligned) element.style.textAlign = 'right';\n  element.textContent = visualChannel\n    .replace('connection', 'line')\n    .replaceAll('_', ' ');\n\n  return element;\n}\n\nfunction createEncoding() {\n  const element = document.createElement('div');\n  element.className = 'legend-encoding';\n  element.style.display = 'grid';\n  element.style.gridTemplateColumns = 'max-content max-content';\n  element.style.gap = '0 0.2rem';\n\n  return element;\n}\n\nfunction createLegend(encodings, fontColor, backgroundColor, size) {\n  const f = fontColor ? fontColor[0] * 255 : 0;\n  const b = backgroundColor ? backgroundColor[0] * 255 : 255;\n\n  let sizePx = 10;\n  if (size === 'medium') sizePx = 12;\n  else if (size === 'large') sizePx = 16;\n\n  const root = document.createElement('div');\n  root.className = 'legend';\n  root.style.display = 'flex';\n  root.style.gap = sizePx + 'px';\n  root.style.margin = (sizePx * 0.2) + 'px';\n  root.style.padding = (sizePx * 0.25) + 'px';\n  root.style.fontSize = sizePx + 'px';\n  root.style.borderRadius = (sizePx * 0.25) + 'px';\n  root.style.color = 'rgb(' + f + ', ' + f + ', ' + f + ')';\n  root.style.backgroundColor = 'rgba(' + b + ', ' + b + ', ' + b + ', 0.85)';\n  root.style.pointerEvents = 'none';\n  root.style.userSelect = 'none';\n\n  Object.entries(encodings)\n    .sort((a, b) => sortOrder[a[0]] - sortOrder[b[0]])\n    .forEach((encodingEntry) => {\n      const visualChannel = encodingEntry[0];\n      const visualEncoding = encodingEntry[1];\n      const encoding = createEncoding();\n      encoding.appendChild(createTitle(visualChannel, Boolean(visualEncoding.variable)));\n      encoding.appendChild(createLabel(visualEncoding.variable));\n\n      const valueRange = [\n        visualEncoding.values[0][0],\n        visualEncoding.values[visualEncoding.values.length - 1][0]\n      ];\n\n      const encodingRange = [\n        visualEncoding.values[0][1],\n        visualEncoding.values[visualEncoding.values.length - 1][1]\n      ];\n\n      const formatter = createLabelFormatter(valueRange);\n\n      const values = typeof visualEncoding.values[0][0] === 'number'\n        ? [...visualEncoding.values].reverse()\n        : visualEncoding.values;\n\n      values.forEach(([value, encodedValue, label]) => {\n        encoding.appendChild(\n          createEntry(\n            visualChannel,\n            formatter(value),\n            encodedValue,\n            encodingRange,\n            sizePx,\n            f\n          )\n        );\n        encoding.appendChild(createLabel(label));\n      });\n\n      root.append(encoding);\n    });\n\n  return root;\n}\n\nmodule.exports = createLegend;\n"],"names":[],"sourceRoot":""}